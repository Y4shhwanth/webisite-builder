<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Website Builder - Topmate</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f0f;
            min-height: 100vh;
            color: #fff;
        }

        /* ========== LOVABLE-STYLE LAYOUT ========== */
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* LEFT PANEL - Chat */
        .chat-panel {
            width: 400px;
            min-width: 400px;
            background: #1a1a1a;
            border-right: 1px solid #2a2a2a;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .chat-panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-panel-logo {
            font-weight: 700;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .chat-panel-title {
            font-size: 13px;
            color: #b0b0b0;
        }

        .chat-messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .chat-message {
            margin-bottom: 16px;
            animation: fadeIn 0.3s ease;
        }

        .chat-message.user {
            display: flex;
            justify-content: flex-end;
        }

        .chat-message.user .chat-message-content {
            background: #2563eb;
            color: white;
            border-radius: 16px 16px 4px 16px;
            max-width: 85%;
        }

        .chat-message.assistant .chat-message-content {
            background: #2a2a2a;
            color: #e5e5e5;
            border-radius: 16px 16px 16px 4px;
            max-width: 85%;
        }

        .chat-message-content {
            padding: 12px 16px;
            font-size: 14px;
            line-height: 1.5;
        }

        .chat-input-container {
            padding: 16px 20px;
            border-top: 1px solid #2a2a2a;
            background: #1a1a1a;
        }

        .chat-input-wrapper {
            background: #2a2a2a;
            border-radius: 12px;
            border: 1px solid #3a3a3a;
            overflow: hidden;
            transition: border-color 0.2s;
        }

        .chat-input-wrapper:focus-within {
            border-color: #667eea;
        }

        .chat-input {
            width: 100%;
            background: transparent;
            border: none;
            color: #fff;
            padding: 14px 16px;
            font-size: 14px;
            resize: none;
            outline: none;
            font-family: inherit;
        }

        .chat-input::placeholder {
            color: #888;
        }

        .chat-input-actions {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-top: 1px solid #3a3a3a;
        }

        .chat-input-hint {
            font-size: 12px;
            color: #999;
        }

        .chat-send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
        }

        .chat-send-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* ========== SUGGESTION CHIPS ========== */
        .suggestion-chips-container {
            padding: 10px 16px;
            border-top: 1px solid #2a2a2a;
            background: #1a1a1a;
        }

        .suggestion-chips-label {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .suggestion-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .suggestion-chip {
            padding: 8px 14px;
            background: rgba(102, 126, 234, 0.15);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 18px;
            font-size: 12px;
            font-weight: 500;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: chipFadeIn 0.2s ease forwards;
            opacity: 0;
        }

        .suggestion-chip:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
            color: #fff;
            transform: translateY(-1px);
        }

        @keyframes chipFadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .suggestion-chip:nth-child(1) { animation-delay: 0ms; }
        .suggestion-chip:nth-child(2) { animation-delay: 40ms; }
        .suggestion-chip:nth-child(3) { animation-delay: 80ms; }
        .suggestion-chip:nth-child(4) { animation-delay: 120ms; }
        .suggestion-chip:nth-child(5) { animation-delay: 160ms; }

        .suggestion-chip-icon {
            font-size: 12px;
        }

        /* ========== HISTORY TIMELINE ========== */
        .history-panel {
            position: fixed;
            left: 380px;
            top: 0;
            bottom: 0;
            width: 280px;
            background: #1a1a1a;
            border-right: 1px solid #2a2a2a;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0,0,0,0.3);
        }

        .history-panel.open {
            transform: translateX(0);
        }

        .history-panel-header {
            padding: 16px;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .history-panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        .history-panel-close {
            width: 28px;
            height: 28px;
            background: #2a2a2a;
            border: none;
            border-radius: 6px;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
        }

        .history-panel-close:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .history-timeline {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .history-item {
            position: relative;
            padding-left: 20px;
            padding-bottom: 20px;
            border-left: 2px solid #3a3a3a;
            margin-left: 6px;
        }

        .history-item:last-child {
            border-left-color: transparent;
            padding-bottom: 0;
        }

        .history-item::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 0;
            width: 8px;
            height: 8px;
            background: #3a3a3a;
            border-radius: 50%;
        }

        .history-item.current::before {
            background: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .history-item-time {
            font-size: 10px;
            color: #999;
            margin-bottom: 4px;
        }

        .history-item-desc {
            font-size: 12px;
            color: #e0e0e0;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .history-item-thumb {
            width: 100%;
            aspect-ratio: 16/10;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            background: #2a2a2a;
            cursor: pointer;
            transition: all 0.2s;
        }

        .history-item-thumb:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .history-item-thumb iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 1280px;
            height: 800px;
            transform-origin: top left;
            pointer-events: none;
            border: none;
        }

        .history-item-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .history-action-btn {
            padding: 5px 10px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            font-size: 11px;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
        }

        .history-action-btn:hover {
            background: #3a3a3a;
            border-color: #667eea;
        }

        .history-action-btn.restore {
            background: #667eea;
            border-color: #667eea;
            color: #fff;
        }


        .history-empty {
            text-align: center;
            padding: 40px 20px;
            color: #999;
            font-size: 13px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* RIGHT PANEL - Preview */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f0f0f;
            overflow: hidden;
        }

        .preview-header {
            height: 50px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .preview-url-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #2a2a2a;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            color: #c0c0c0;
        }

        .preview-actions {
            display: flex;
            gap: 8px;
        }

        .preview-content {
            flex: 1;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .canvas-wrapper {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.3);
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .preview-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ========== DEVICE PREVIEW MODES ========== */
        .device-mode-controls {
            display: flex;
            gap: 2px;
            background: #2a2a2a;
            padding: 4px;
            border-radius: 8px;
        }

        .device-mode-btn {
            width: 36px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            border-radius: 6px;
            color: #b0b0b0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .device-mode-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .device-mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }

        .device-mode-btn svg {
            width: 18px;
            height: 18px;
        }

        .canvas-wrapper.tablet-mode {
            max-width: 768px;
            margin: 0 auto;
            transition: all 0.3s ease;
        }

        .canvas-wrapper.mobile-mode {
            max-width: 375px;
            margin: 0 auto;
            border-radius: 32px;
            transition: all 0.3s ease;
        }

        /* Zoom Controls */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #2a2a2a;
            padding: 4px 8px;
            border-radius: 8px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.08);
            border: none;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .zoom-level {
            font-size: 12px;
            color: #e0e0e0;
            min-width: 45px;
            text-align: center;
        }

        /* ========== BUTTONS ========== */
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn-ghost {
            background: rgba(255, 255, 255, 0.08);
            color: #e0e0e0;
        }

        .btn-ghost:hover {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
        }

        .btn-outline {
            background: transparent;
            color: #667eea;
            border: 1px solid #667eea;
        }

        .btn-outline:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .btn-history {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }

        .btn-history:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-history svg {
            flex-shrink: 0;
        }

        .history-badge {
            background: #ef4444;
            color: white;
            font-size: 10px;
            font-weight: 600;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 5px;
            margin-left: 2px;
        }

        .history-badge:empty,
        .history-badge[data-count="0"] {
            display: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-size: 16px;
            background: #2a2a2a;
            color: #888;
            border: none;
            cursor: pointer;
        }

        .btn-icon:hover {
            background: #3a3a3a;
            color: #fff;
        }

        /* Hide old elements */
        .main-content, .top-bar, .canvas-area, .ai-sidebar {
            display: none !important;
        }

        /* ========== WELCOME SCREEN ========== */
        .welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .welcome-screen.hidden {
            display: none;
        }

        .welcome-content {
            text-align: center;
            max-width: 500px;
            padding: 40px;
        }

        .welcome-content h1 {
            font-size: 32px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .welcome-content p {
            color: #666;
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .input-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* ========== TEMPLATE SELECTION ========== */
        .template-section {
            margin-bottom: 24px;
        }

        .template-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            text-align: left;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .template-card {
            position: relative;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            text-align: left;
        }

        .template-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .template-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
        }

        .template-card.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .template-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .template-icon.minimal { background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%); }
        .template-icon.bold { background: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%); }
        .template-icon.corporate { background: linear-gradient(135deg, #1a365d 0%, #2d3748 100%); color: white; }
        .template-icon.dark { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #ffd700; }
        .template-icon.gradient { background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); color: white; }

        .template-name {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .template-desc {
            font-size: 11px;
            color: #666;
            line-height: 1.4;
        }

        .welcome-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .welcome-actions .btn {
            flex: 1;
            padding: 14px;
        }

        /* ========== LOADING OVERLAY ========== */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 100;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #666;
            font-size: 14px;
        }

        /* ========== AI SIDEBAR ========== */
        .ai-sidebar {
            width: 380px;
            background: white;
            border-left: 1px solid #e5e5e5;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            position: absolute;
            right: 0;
            top: 56px;
            bottom: 0;
            z-index: 50;
        }

        .ai-sidebar.open {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-header h3 {
            font-size: 15px;
            font-weight: 600;
        }

        .sidebar-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
            padding: 4px;
        }

        .sidebar-close:hover {
            color: #333;
        }

        /* ========== CONTEXT PANEL (Shows selected element info) ========== */
        .context-panel {
            padding: 16px 20px;
            background: #f8f9ff;
            border-bottom: 1px solid #e5e5e5;
            display: none;
        }

        .context-panel.active {
            display: block;
        }

        .context-label {
            font-size: 11px;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .context-element {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .context-text {
            font-size: 13px;
            color: #666;
            margin-top: 6px;
            padding: 8px;
            background: white;
            border-radius: 6px;
            max-height: 60px;
            overflow: hidden;
        }

        /* ========== DIRECT TEXT EDIT ========== */
        .direct-edit-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e5e5;
        }

        .direct-edit-label {
            font-size: 11px;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .direct-edit-wrapper {
            display: flex;
            gap: 8px;
        }

        .direct-edit-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 13px;
            resize: none;
            font-family: inherit;
        }

        .direct-edit-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .direct-edit-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .direct-edit-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* ========== QUICK ACTIONS ========== */
        .quick-actions {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
        }

        .quick-actions-title {
            font-size: 12px;
            color: #999;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quick-actions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .quick-action-btn {
            padding: 10px 12px;
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quick-action-btn:hover {
            background: #e8f0ff;
            border-color: #667eea;
        }

        .quick-action-btn .icon {
            font-size: 14px;
        }

        /* ========== CHAT AREA ========== */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .chat-message {
            margin-bottom: 12px;
            max-width: 90%;
        }

        .chat-message.user {
            margin-left: auto;
        }

        .chat-message-content {
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 13px;
            line-height: 1.5;
        }

        .chat-message.user .chat-message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-message-content {
            background: #2a2a2a;
            color: #e0e0e0;
            border-bottom-left-radius: 4px;
        }

        .chat-suggestions {
            padding: 12px 20px;
            border-top: 1px solid #2a2a2a;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        /* Duplicate removed - using main suggestion-chip styles */

        .chat-input-area {
            padding: 16px 20px;
            border-top: 1px solid #2a2a2a;
            display: flex;
            gap: 10px;
        }

        /* Using main .chat-input styles from line 114 */

        .chat-send-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
        }

        .chat-send-btn:hover {
            opacity: 0.9;
        }

        /* ========== BLOCK SELECTION OVERLAY ========== */
        .block-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }

        .block-highlight {
            position: absolute;
            border: 2px solid transparent;
            transition: all 0.15s;
            pointer-events: auto;
            cursor: pointer;
        }

        .block-highlight:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .block-highlight.selected {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.08);
        }

        .block-label {
            position: absolute;
            top: -26px;
            left: 0;
            background: #667eea;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            opacity: 0;
            transition: opacity 0.15s;
            white-space: nowrap;
        }

        .block-highlight:hover .block-label,
        .block-highlight.selected .block-label {
            opacity: 1;
        }

        /* ========== INLINE EDIT INPUT ========== */
        .inline-edit-container {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            min-width: 300px;
            max-width: 500px;
        }

        .inline-edit-container.active {
            display: block;
        }

        .inline-edit-textarea {
            width: 100%;
            min-height: 60px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            padding: 10px;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 10px;
        }

        .inline-edit-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .inline-edit-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .inline-edit-btn {
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            border: none;
        }

        .inline-edit-btn.cancel {
            background: #f5f5f5;
            color: #666;
        }

        .inline-edit-btn.save {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* ========== BOTTOM TOOLBAR ========== */
        .bottom-toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 8px 12px;
            display: none;
            gap: 6px;
            z-index: 100;
        }

        .bottom-toolbar.visible {
            display: flex;
        }

        .bottom-tool-btn {
            padding: 10px 16px;
            background: #f5f5f5;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .bottom-tool-btn:hover {
            background: #e8e8e8;
        }

        .bottom-tool-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* ========== TOAST NOTIFICATIONS ========== */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.visible {
            opacity: 1;
        }

        .toast.success {
            background: #28a745;
        }

        .toast.error {
            background: #dc3545;
        }

        /* ========== ENHANCED TYPING INDICATOR ========== */
        .typing-message {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
        }

        .typing-avatar {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .typing-avatar svg {
            width: 20px;
            height: 20px;
            color: white;
        }

        .typing-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 12px 16px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            border-radius: 12px 12px 12px 4px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out both;
        }

        .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .typing-dots span:nth-child(2) { animation-delay: 0.16s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.32s; }

        @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-6px); }
        }

        .typing-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #888;
        }

        .typing-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .typing-stages {
            display: flex;
            gap: 16px;
            font-size: 11px;
            margin-top: 4px;
        }

        .typing-stage {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #555;
            opacity: 0.4;
            transition: all 0.3s;
        }

        .typing-stage.active {
            color: #667eea;
            opacity: 1;
        }

        .typing-stage.completed {
            color: #10b981;
            opacity: 1;
        }

        .typing-stage-icon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid currentColor;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
        }

        .typing-stage.active .typing-stage-icon {
            border-color: transparent;
            background: #667eea;
            color: white;
        }

        .typing-stage.completed .typing-stage-icon {
            border-color: transparent;
            background: #10b981;
            color: white;
        }

        /* ========== TOOLTIPS SYSTEM ========== */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::before,
        [data-tooltip]::after {
            position: absolute;
            visibility: hidden;
            opacity: 0;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 10000;
        }

        [data-tooltip]::before {
            content: attr(data-tooltip);
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            padding: 6px 10px;
            background: rgba(15, 15, 15, 0.95);
            color: #e0e0e0;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        [data-tooltip]::after {
            content: '';
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            border: 6px solid transparent;
            border-top-color: rgba(15, 15, 15, 0.95);
        }

        [data-tooltip]:hover::before,
        [data-tooltip]:hover::after {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Bottom tooltip variant */
        [data-tooltip-position="bottom"]::before {
            bottom: auto;
            top: calc(100% + 8px);
            transform: translateX(-50%) translateY(-4px);
        }

        [data-tooltip-position="bottom"]::after {
            bottom: auto;
            top: calc(100% + 2px);
            border-top-color: transparent;
            border-bottom-color: rgba(15, 15, 15, 0.95);
            transform: translateX(-50%) translateY(-4px);
        }

        [data-tooltip-position="bottom"]:hover::before,
        [data-tooltip-position="bottom"]:hover::after {
            transform: translateX(-50%) translateY(0);
        }

        /* Left tooltip variant */
        [data-tooltip-position="left"]::before {
            bottom: auto;
            left: auto;
            right: calc(100% + 8px);
            top: 50%;
            transform: translateY(-50%) translateX(4px);
        }

        [data-tooltip-position="left"]::after {
            bottom: auto;
            left: auto;
            right: calc(100% + 2px);
            top: 50%;
            transform: translateY(-50%) translateX(4px);
            border-top-color: transparent;
            border-left-color: rgba(15, 15, 15, 0.95);
        }

        [data-tooltip-position="left"]:hover::before,
        [data-tooltip-position="left"]:hover::after {
            transform: translateY(-50%) translateX(0);
        }

        /* Right tooltip variant */
        [data-tooltip-position="right"]::before {
            bottom: auto;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-50%) translateX(-4px);
        }

        [data-tooltip-position="right"]::after {
            bottom: auto;
            left: calc(100% + 2px);
            top: 50%;
            transform: translateY(-50%) translateX(-4px);
            border-top-color: transparent;
            border-right-color: rgba(15, 15, 15, 0.95);
        }

        [data-tooltip-position="right"]:hover::before,
        [data-tooltip-position="right"]:hover::after {
            transform: translateY(-50%) translateX(0);
        }

        /* ========== LOADING STATES & ANIMATIONS ========== */

        /* Modern dual-ring spinner */
        .spinner-dual-ring {
            width: 40px;
            height: 40px;
            position: relative;
        }

        .spinner-dual-ring::before,
        .spinner-dual-ring::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 3px solid transparent;
        }

        .spinner-dual-ring::before {
            border-top-color: #667eea;
            animation: dualRingSpin 1s ease-in-out infinite;
        }

        .spinner-dual-ring::after {
            border-bottom-color: #764ba2;
            animation: dualRingSpin 1s ease-in-out infinite reverse;
            animation-delay: 0.3s;
        }

        @keyframes dualRingSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Indeterminate progress bar */
        .progress-bar-indeterminate {
            width: 100%;
            height: 3px;
            background: rgba(102, 126, 234, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-indeterminate::before {
            content: '';
            position: absolute;
            width: 30%;
            height: 100%;
            background: linear-gradient(90deg, transparent, #667eea, #764ba2, transparent);
            animation: progressIndeterminate 1.5s ease-in-out infinite;
        }

        @keyframes progressIndeterminate {
            0% { left: -30%; }
            100% { left: 100%; }
        }

        /* Skeleton loading */
        .skeleton {
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.05) 25%,
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.05) 75%
            );
            background-size: 200% 100%;
            animation: skeletonShimmer 1.5s ease-in-out infinite;
            border-radius: 4px;
        }

        @keyframes skeletonShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-text {
            height: 14px;
            margin-bottom: 8px;
        }

        .skeleton-text:last-child {
            width: 60%;
        }

        .skeleton-avatar {
            width: 36px;
            height: 36px;
            border-radius: 10px;
        }

        .skeleton-message {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
        }

        .skeleton-message-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Button loading state */
        .btn-loading {
            position: relative;
            pointer-events: none;
            color: transparent !important;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin: -8px 0 0 -8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        /* Fade animations */
        .fade-enter {
            opacity: 0;
            transform: translateY(10px);
        }

        .fade-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s ease;
        }

        .fade-exit {
            opacity: 1;
        }

        .fade-exit-active {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        /* Scale animations */
        .scale-enter {
            opacity: 0;
            transform: scale(0.9);
        }

        .scale-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: all 0.2s ease;
        }

        /* Slide animations */
        .slide-up-enter {
            opacity: 0;
            transform: translateY(20px);
        }

        .slide-up-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Pulse effect for success states */
        @keyframes successPulse {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }

        .success-pulse {
            animation: successPulse 0.6s ease;
        }

        /* Ripple effect for buttons */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }

        .ripple:active::before {
            width: 200%;
            height: 200%;
        }

        /* ========== WELCOME TABS ========== */
        .welcome-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 24px;
            border-bottom: 2px solid #e5e5e5;
        }

        .welcome-tab {
            flex: 1;
            padding: 12px 20px;
            background: none;
            border: none;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .welcome-tab:hover {
            color: #333;
        }

        .welcome-tab.active {
            color: #667eea;
        }

        .welcome-tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Upload HTML Section */
        .upload-section {
            text-align: left;
        }

        .upload-methods {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .upload-method-btn {
            flex: 1;
            padding: 12px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .upload-method-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-method-btn.active {
            border-color: #667eea;
            border-style: solid;
            background: #f0f3ff;
        }

        .upload-method-btn .icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .upload-method-btn .label {
            font-size: 13px;
            color: #333;
        }

        .html-textarea {
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .html-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-upload-wrapper {
            margin-bottom: 16px;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 40px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: #fafafa;
        }

        .file-input-label:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .file-input-label.has-file {
            border-color: #28a745;
            background: #f0fff4;
        }

        .file-input {
            display: none;
        }

        .file-name {
            font-size: 13px;
            color: #28a745;
            margin-top: 8px;
        }

        /* Image URL Modal */
        .image-url-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .image-url-modal.visible {
            display: flex !important;
        }

        .image-url-modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            width: 450px;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .image-url-modal h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            color: #333;
        }

        .image-url-modal p {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #666;
        }

        .image-url-modal input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            box-sizing: border-box;
            margin-bottom: 16px;
            outline: none;
            transition: border-color 0.2s;
        }

        .image-url-modal input:focus {
            border-color: #667eea;
        }

        .image-url-modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .image-url-modal-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .image-url-modal-buttons .cancel-btn {
            border: 1px solid #ddd;
            background: white;
            color: #666;
        }

        .image-url-modal-buttons .confirm-btn {
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <!-- NEW LOVABLE-STYLE LAYOUT -->
    <div class="app-container">
        <!-- LEFT PANEL - Chat -->
        <div class="chat-panel">
            <div class="chat-panel-header">
                <span class="chat-panel-logo">AI Builder</span>
                <span class="chat-panel-title">by Topmate</span>
            </div>

            <div class="chat-messages-container" id="chatMessagesNew">
                <!-- Messages appear here -->
            </div>

            <!-- Suggestion Chips -->
            <div class="suggestion-chips-container" id="suggestionChipsContainer">
                <div class="suggestion-chips-label">Quick Actions</div>
                <div class="suggestion-chips" id="suggestionChips">
                    <!-- Chips populated dynamically -->
                </div>
            </div>

            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <textarea class="chat-input" id="chatInputNew" placeholder="Describe what you want to change..." rows="3" onkeydown="handleChatKeydownNew(event)"></textarea>
                    <div class="chat-input-actions">
                        <span class="chat-input-hint">Press Enter to send</span>
                        <button class="chat-send-btn" onclick="sendChatMessageNew()">Send</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL - Preview -->
        <div class="preview-panel">
            <div class="preview-header">
                <div class="preview-url-bar">
                    <span>ðŸŒ</span>
                    <span id="previewUrl">your-website.topmate.io</span>
                </div>

                <!-- Device Mode Controls -->
                <div class="device-mode-controls" id="deviceModeControls">
                    <button class="device-mode-btn active" data-mode="desktop" onclick="setDeviceMode('desktop')" data-tooltip="Desktop (Ctrl+1)" data-tooltip-position="bottom">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="2" y="3" width="20" height="14" rx="2"/>
                            <line x1="8" y1="21" x2="16" y2="21"/>
                            <line x1="12" y1="17" x2="12" y2="21"/>
                        </svg>
                    </button>
                    <button class="device-mode-btn" data-mode="tablet" onclick="setDeviceMode('tablet')" data-tooltip="Tablet (Ctrl+2)" data-tooltip-position="bottom">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="4" y="2" width="16" height="20" rx="2"/>
                            <circle cx="12" cy="18" r="1"/>
                        </svg>
                    </button>
                    <button class="device-mode-btn" data-mode="mobile" onclick="setDeviceMode('mobile')" data-tooltip="Mobile (Ctrl+3)" data-tooltip-position="bottom">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="5" y="2" width="14" height="20" rx="2"/>
                            <circle cx="12" cy="18" r="1"/>
                        </svg>
                    </button>
                </div>

                <!-- Zoom Controls -->
                <div class="zoom-controls" id="zoomControls">
                    <button class="zoom-btn" onclick="adjustZoom(-10)" data-tooltip="Zoom out" data-tooltip-position="bottom">âˆ’</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-btn" onclick="adjustZoom(10)" data-tooltip="Zoom in" data-tooltip-position="bottom">+</button>
                </div>

                <div class="preview-actions">
                    <button class="btn btn-ghost" onclick="undoAction()" data-tooltip="Ctrl+Z" data-tooltip-position="bottom">Undo</button>
                    <button class="btn btn-ghost" onclick="polishAll()" data-tooltip="Fix spacing & layout" data-tooltip-position="bottom">Fix Layout</button>
                    <button class="btn btn-history" onclick="toggleHistoryPanel()" data-tooltip="Version History (Ctrl+H)" data-tooltip-position="bottom" id="historyBtn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12 6 12 12 16 14"/>
                        </svg>
                        History
                        <span class="history-badge" id="historyBadge">0</span>
                    </button>
                    <button class="btn btn-ghost" onclick="resetForm()" data-tooltip="Start fresh" data-tooltip-position="bottom">New</button>
                    <button class="btn btn-outline" onclick="downloadHTML()" data-tooltip="Save as HTML (Ctrl+S)" data-tooltip-position="bottom">Download</button>
                </div>
            </div>

            <div class="preview-content">
                <div class="canvas-wrapper" id="newCanvasWrapper">
                    <!-- Welcome Screen with Full Features -->
                    <div class="welcome-screen" id="welcomeScreenNew" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: #f8f9fa; padding: 40px; overflow-y: auto;">
                        <h1 style="font-size: 32px; color: #1a1a1a; margin-bottom: 8px; font-weight: 700;">AI Website Builder</h1>
                        <p style="color: #666; margin-bottom: 32px; font-size: 15px;">Create stunning websites with AI or edit your own HTML</p>

                        <!-- Tabs -->
                        <div style="display: flex; gap: 0; margin-bottom: 24px; background: #e9ecef; border-radius: 8px; padding: 4px;">
                            <button class="welcome-tab-new active" onclick="switchWelcomeTabNew('generate')" style="padding: 10px 24px; border: none; background: #fff; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; color: #1a1a1a;">Generate New</button>
                            <button class="welcome-tab-new" onclick="switchWelcomeTabNew('upload')" style="padding: 10px 24px; border: none; background: transparent; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; color: #666;">Upload HTML</button>
                            <button class="welcome-tab-new" onclick="switchWelcomeTabNew('paste')" style="padding: 10px 24px; border: none; background: transparent; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; color: #666;">Paste HTML</button>
                        </div>

                        <!-- Tab 1: Generate -->
                        <div id="generateTabNew" class="tab-content-new" style="width: 100%; max-width: 600px;">
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; font-size: 13px; color: #666; margin-bottom: 8px; font-weight: 500;">Topmate Username</label>
                                <input type="text" id="usernameNew" placeholder="Enter your Topmate username" style="width: 100%; padding: 14px 16px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; outline: none;">
                            </div>

                            <!-- Template Selection -->
                            <div style="margin-bottom: 24px;">
                                <label style="display: block; font-size: 13px; color: #666; margin-bottom: 12px; font-weight: 500;">Choose a Template Style</label>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                                    <div class="template-card-new selected" data-template="modern-minimal" onclick="selectTemplateNew(this)" style="padding: 16px; border: 2px solid #667eea; border-radius: 10px; cursor: pointer; text-align: center; background: #f8f9ff;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">â—»ï¸</div>
                                        <div style="font-size: 13px; font-weight: 600; color: #1a1a1a;">Modern Minimal</div>
                                        <div style="font-size: 11px; color: #888; margin-top: 4px;">Clean & focused</div>
                                    </div>
                                    <div class="template-card-new" data-template="bold-creative" onclick="selectTemplateNew(this)" style="padding: 16px; border: 2px solid #e5e7eb; border-radius: 10px; cursor: pointer; text-align: center; background: #fff;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸŽ¨</div>
                                        <div style="font-size: 13px; font-weight: 600; color: #1a1a1a;">Bold & Creative</div>
                                        <div style="font-size: 11px; color: #888; margin-top: 4px;">Vibrant colors</div>
                                    </div>
                                    <div class="template-card-new" data-template="professional" onclick="selectTemplateNew(this)" style="padding: 16px; border: 2px solid #e5e7eb; border-radius: 10px; cursor: pointer; text-align: center; background: #fff;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">ðŸ’¼</div>
                                        <div style="font-size: 13px; font-weight: 600; color: #1a1a1a;">Professional</div>
                                        <div style="font-size: 11px; color: #888; margin-top: 4px;">Business focused</div>
                                    </div>
                                </div>
                            </div>

                            <button class="btn btn-primary" onclick="generateWebsiteNew()" style="width: 100%; padding: 14px 24px; font-size: 15px; font-weight: 600;">Generate Website</button>
                        </div>

                        <!-- Tab 2: Upload -->
                        <div id="uploadTabNew" class="tab-content-new" style="display: none; width: 100%; max-width: 600px;">
                            <div style="border: 2px dashed #ddd; border-radius: 12px; padding: 48px; text-align: center; background: #fff;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ðŸ“</div>
                                <div style="font-size: 16px; color: #1a1a1a; margin-bottom: 8px; font-weight: 500;">Drop your HTML file here</div>
                                <div style="font-size: 13px; color: #888; margin-bottom: 20px;">or click to browse</div>
                                <input type="file" id="htmlUploadNew" accept=".html,.htm" onchange="handleFileUploadNew(event)" style="display: none;">
                                <button onclick="document.getElementById('htmlUploadNew').click()" style="padding: 12px 32px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">Choose File</button>
                            </div>
                        </div>

                        <!-- Tab 3: Paste -->
                        <div id="pasteTabNew" class="tab-content-new" style="display: none; width: 100%; max-width: 600px;">
                            <div style="margin-bottom: 16px;">
                                <label style="display: block; font-size: 13px; color: #666; margin-bottom: 8px; font-weight: 500;">Paste your HTML code</label>
                                <textarea id="pasteHtmlNew" placeholder="<!DOCTYPE html>..." style="width: 100%; height: 200px; padding: 14px 16px; border: 1px solid #ddd; border-radius: 8px; font-size: 13px; font-family: monospace; outline: none; resize: vertical;"></textarea>
                            </div>
                            <button class="btn btn-primary" onclick="loadPastedHtmlNew()" style="width: 100%; padding: 14px 24px; font-size: 15px; font-weight: 600;">Load HTML</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- OLD LAYOUT (hidden) -->
    <div class="app-container" style="display: none;">
        <div class="main-content">
            <!-- Top Bar -->
            <div class="top-bar">
                <div class="logo">AI Website Builder</div>
                <div class="top-bar-divider"></div>
                <span class="project-name" id="projectName">New Website</span>
                <div class="top-bar-spacer"></div>
                <div class="top-bar-actions">
                    <button class="btn btn-ghost" onclick="resetForm()">New</button>
                    <button class="btn btn-outline" onclick="downloadHTML()">Download</button>
                    <button class="btn btn-primary btn-icon" onclick="toggleAISidebar()" title="AI Assistant">AI</button>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <!-- Welcome Screen -->
                    <div class="welcome-screen" id="welcomeScreen">
                        <div class="welcome-content">
                            <h1>AI Website Builder</h1>
                            <p>Create stunning websites with AI or edit your own HTML</p>

                            <!-- Tabs -->
                            <div class="welcome-tabs">
                                <button class="welcome-tab active" onclick="switchWelcomeTab('generate')">Generate New</button>
                                <button class="welcome-tab" onclick="switchWelcomeTab('upload')">Upload HTML</button>
                            </div>

                            <!-- Tab 1: Generate New Website -->
                            <div class="tab-content active" id="generateTab">
                                <div class="input-group">
                                    <label>Topmate Username</label>
                                    <input type="text" id="username" placeholder="Enter your Topmate username">
                                </div>

                                <!-- Template Selection -->
                                <div class="template-section">
                                    <div class="template-section-title">Choose a Template Style</div>
                                    <div class="template-grid">
                                        <div class="template-card selected" data-template="modern-minimal" onclick="selectTemplate(this)">
                                            <div class="template-icon minimal">â—»ï¸</div>
                                            <div class="template-name">Modern Minimal</div>
                                            <div class="template-desc">Clean design with focus on content</div>
                                        </div>
                                        <div class="template-card" data-template="bold-creative" onclick="selectTemplate(this)">
                                            <div class="template-icon bold">ðŸŽ¨</div>
                                            <div class="template-name">Bold & Creative</div>
                                            <div class="template-desc">Vibrant colors, dynamic layouts</div>
                                        </div>
                                        <div class="template-card" data-template="professional-corporate" onclick="selectTemplate(this)">
                                            <div class="template-icon corporate">ðŸ’¼</div>
                                            <div class="template-name">Professional</div>
                                            <div class="template-desc">Trust-building business design</div>
                                        </div>
                                        <div class="template-card" data-template="dark-elegant" onclick="selectTemplate(this)">
                                            <div class="template-icon dark">ðŸŒ™</div>
                                            <div class="template-name">Dark & Elegant</div>
                                            <div class="template-desc">Sophisticated dark theme</div>
                                        </div>
                                        <div class="template-card" data-template="vibrant-gradient" onclick="selectTemplate(this)">
                                            <div class="template-icon gradient">âœ¨</div>
                                            <div class="template-name">Vibrant Gradient</div>
                                            <div class="template-desc">Eye-catching glass effects</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="input-group">
                                    <label>Custom Instructions (Optional)</label>
                                    <textarea id="userPrompt" placeholder="e.g., Focus on my consulting services, highlight testimonials"></textarea>
                                </div>

                                <div class="welcome-actions">
                                    <button class="btn btn-primary" onclick="generateWebsite()">Generate Website</button>
                                </div>
                            </div>

                            <!-- Tab 2: Upload HTML -->
                            <div class="tab-content" id="uploadTab">
                                <div class="upload-section">
                                    <div class="upload-methods">
                                        <div class="upload-method-btn active" onclick="switchUploadMethod('paste')">
                                            <div class="icon">ðŸ“‹</div>
                                            <div class="label">Paste HTML</div>
                                        </div>
                                        <div class="upload-method-btn" onclick="switchUploadMethod('file')">
                                            <div class="icon">ðŸ“</div>
                                            <div class="label">Upload File</div>
                                        </div>
                                    </div>

                                    <!-- Paste HTML Section -->
                                    <div id="pasteSection">
                                        <textarea class="html-textarea" id="htmlInput" placeholder="Paste your HTML code here...

<!DOCTYPE html>
<html>
<head>
    <title>My Website</title>
</head>
<body>
    <!-- Your content here -->
</body>
</html>"></textarea>
                                    </div>

                                    <!-- File Upload Section -->
                                    <div id="fileSection" style="display: none;">
                                        <div class="file-upload-wrapper">
                                            <label class="file-input-label" id="fileInputLabel">
                                                <span>ðŸ“„ Drop HTML file here or click to browse</span>
                                                <input type="file" class="file-input" id="htmlFileInput" accept=".html,.htm" onchange="handleFileUpload(event)">
                                            </label>
                                            <div class="file-name" id="fileName" style="display: none;"></div>
                                        </div>
                                    </div>

                                    <div class="welcome-actions">
                                        <button class="btn btn-primary" onclick="loadUploadedHTML()">Load & Edit</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Loading Overlay -->
                    <div class="loading-overlay" id="loadingOverlay">
                        <div class="spinner"></div>
                        <div class="loading-text">Creating your website...</div>
                    </div>

                    <!-- Preview Frame -->
                    <iframe id="previewFrame" class="preview-frame"></iframe>

                    <!-- Block Overlay -->
                    <div class="block-overlay" id="blockOverlay"></div>
                </div>
            </div>
        </div>

        <!-- AI Sidebar -->
        <div class="ai-sidebar" id="aiSidebar">
            <div class="sidebar-header" style="padding: 12px 16px; border-bottom: 1px solid #e5e7eb;">
                <h3 style="margin: 0; font-size: 14px; color: #6b7280;">AI Editor</h3>
                <button class="sidebar-close" onclick="toggleAISidebar()">&times;</button>
            </div>

            <!-- Hidden context panel (needed for functionality) -->
            <div class="context-panel" id="contextPanel" style="display: none;">
                <div class="context-element" id="contextElement"></div>
                <div class="context-text" id="contextText"></div>
            </div>

            <!-- Clean Chat Area -->
            <div class="chat-area" style="display: flex; flex-direction: column; height: calc(100% - 50px);">
                <div class="chat-messages" id="chatMessages" style="flex: 1; overflow-y: auto; padding: 16px;">
                    <!-- Messages will appear here -->
                </div>

                <div class="chat-input-area" style="padding: 16px; border-top: 1px solid #2a2a2a; background: #1a1a1a;">
                    <textarea class="chat-input" id="chatInput" placeholder="Describe changes... (e.g., 'make it darker', 'change text to...')" rows="2" onkeydown="handleChatKeydown(event)" style="width: 100%; border: 1px solid #3a3a3a; border-radius: 8px; padding: 12px; font-size: 14px; resize: none; margin-bottom: 8px; background: #2a2a2a; color: #e0e0e0;"></textarea>
                    <button class="chat-send-btn" onclick="sendChatMessage()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: 500;">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Image URL Modal Overlay -->
    <div id="imageUrlModal" class="image-url-modal">
        <div class="image-url-modal-content">
            <h3>Replace Image URL</h3>
            <p>Enter the new image URL below:</p>
            <input type="text" id="imageUrlInput" placeholder="https://example.com/image.jpg">
            <div class="image-url-modal-buttons">
                <button class="cancel-btn" onclick="closeImageModal()">Cancel</button>
                <button class="confirm-btn" onclick="confirmImageUrl()">Replace Image</button>
            </div>
        </div>
    </div>

    <!-- Inline Edit Container -->
    <div class="inline-edit-container" id="inlineEditContainer">
        <textarea class="inline-edit-textarea" id="inlineEditText" placeholder="Edit text..."></textarea>
        <div class="inline-edit-actions">
            <button class="inline-edit-btn cancel" onclick="cancelInlineEdit()">Cancel</button>
            <button class="inline-edit-btn save" onclick="saveInlineEdit()">Save</button>
        </div>
    </div>

    <!-- Bottom Toolbar -->
    <div class="bottom-toolbar" id="bottomToolbar">
        <button class="bottom-tool-btn" id="editModeBtn" onclick="toggleEditMode()">
            <span>Edit Mode</span>
        </button>
        <button class="bottom-tool-btn" onclick="undoAction()">Undo</button>
        <button class="bottom-tool-btn" onclick="polishAll()">Polish All</button>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- History Panel -->
    <div class="history-panel" id="historyPanel">
        <div class="history-panel-header">
            <span class="history-panel-title">Version History</span>
            <button class="history-panel-close" onclick="toggleHistoryPanel()">Ã—</button>
        </div>
        <div class="history-timeline" id="historyTimeline">
            <div class="history-empty">
                Make some edits to see version history here.
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        // Force development mode by adding ?dev=true to URL or set this to true
        const forceDevMode = new URLSearchParams(window.location.search).get('dev') === 'true';
        const isProduction = !forceDevMode && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';

        // Production URLs
        const PROD_API_BASE = 'http://localhost:8000/api';  // Django backend (not needed for now)
        const PROD_AI_BASE = 'https://webisite-builder-ejfr.onrender.com';  // Render AI Engine

        // Development URLs
        const DEV_API_BASE = 'http://localhost:8000/api';
        const DEV_AI_BASE = 'http://localhost:8001';

        const API_BASE = isProduction ? PROD_API_BASE : DEV_API_BASE;
        const AI_BASE = isProduction ? PROD_AI_BASE : DEV_AI_BASE;

        // Log which backend is being used
        console.log('=== BACKEND CONFIGURATION ===');
        console.log('Hostname:', window.location.hostname);
        console.log('Force dev mode:', forceDevMode);
        console.log('Is production:', isProduction);
        console.log('AI_BASE:', AI_BASE);
        console.log('=============================');

        // ========== STATE ==========
        let currentHTML = '';
        let currentUsername = '';
        let selectedTemplateId = 'modern-minimal';
        let projectId = null;
        let chatSessionId = null;
        let editModeEnabled = false;
        let selectedElement = null;
        let selectedComponent = null;
        let components = [];
        let htmlHistory = [];
        let designContext = null;  // Store design context (fonts, colors, sections)
        let currentDeviceMode = 'desktop';
        let currentZoom = 100;
        let historyMetadata = []; // Store metadata for history timeline

        // ========== DESIGN CONTEXT EXTRACTION ==========
        function extractDesignContext(html) {
            if (!html) {
                designContext = null;
                return;
            }

            try {
                // Create a temporary DOM to parse HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Extract fonts from Google Fonts links or font-family styles
                const fonts = { display: null, body: null, all_fonts: [] };
                const fontLinks = doc.querySelectorAll('link[href*="fonts.googleapis.com"]');
                fontLinks.forEach(link => {
                    const href = link.href || '';
                    const familyMatch = href.match(/family=([^&:]+)/);
                    if (familyMatch) {
                        const fontName = decodeURIComponent(familyMatch[1]).replace(/\+/g, ' ');
                        fonts.all_fonts.push(fontName);
                        if (!fonts.display) fonts.display = fontName;
                        else if (!fonts.body) fonts.body = fontName;
                    }
                });

                // Extract colors from Tailwind classes and CSS variables
                const colors = { primary: null, accent: null, background: null, text: null };
                const bodyClasses = doc.body?.className || '';

                // Check for common color patterns in body/main sections
                const bgMatch = bodyClasses.match(/bg-(\w+-\d+|white|black|gray-\d+)/);
                if (bgMatch) colors.background = bgMatch[0];

                // Extract sections
                const sections = [];
                doc.querySelectorAll('section, header, footer, main, nav').forEach(el => {
                    sections.push({
                        tag: el.tagName.toLowerCase(),
                        type: el.id || el.className.split(' ')[0] || el.tagName.toLowerCase()
                    });
                });

                // Build design context
                designContext = {
                    fonts: fonts,
                    colors: colors,
                    sections: sections,
                    tokens: {
                        spacing_strategy: 'tailwind',
                        border_radius: 'rounded',
                        shadow_style: 'shadow'
                    },
                    template_id: 'custom'
                };

                console.log('Extracted design context:', designContext);
            } catch (error) {
                console.error('Error extracting design context:', error);
                designContext = null;
            }
        }

        // ========== PREVIEW UPDATE ==========
        function updatePreviewFrame(html) {
            console.log('updatePreviewFrame called, html length:', html?.length);

            if (!html) {
                console.error('updatePreviewFrame: No HTML provided');
                return;
            }

            const container = document.querySelector('.canvas-wrapper');
            if (!container) {
                console.error('updatePreviewFrame: canvas-wrapper not found');
                return;
            }

            const oldFrame = document.getElementById('previewFrame');
            console.log('Old frame found:', !!oldFrame);

            // Create new iframe
            const newFrame = document.createElement('iframe');
            newFrame.id = 'previewFrame';
            newFrame.className = 'preview-frame';

            // Replace old iframe BEFORE setting srcdoc to avoid timing issues
            if (oldFrame && oldFrame.parentNode) {
                oldFrame.parentNode.replaceChild(newFrame, oldFrame);
                console.log('Replaced old frame with new frame');
            } else {
                container.appendChild(newFrame);
                console.log('Appended new frame to container');
            }

            // Now set the srcdoc
            newFrame.srcdoc = html;
            console.log('Set srcdoc on new frame');

            // Re-setup listeners after iframe loads
            newFrame.onload = () => {
                console.log('New iframe loaded');
                if (!html) return;
                try {
                    const iframeDoc = newFrame.contentDocument || newFrame.contentWindow.document;
                    iframeDoc.addEventListener('click', handleIframeClick);
                    iframeDoc.addEventListener('dblclick', handleIframeDblClick);
                    iframeDoc.addEventListener('mouseover', handleIframeHover);
                    iframeDoc.addEventListener('mouseout', handleIframeMouseOut);
                    injectEditStyles(iframeDoc);
                    console.log('Iframe listeners set up successfully');
                } catch (e) {
                    console.error('Error setting up iframe listeners:', e);
                }
            };

            console.log('Preview frame updated with HTML length:', html.length);
        }

        // ========== WELCOME TAB SWITCHING ==========
        function switchWelcomeTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.welcome-tab').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.getElementById('generateTab').classList.remove('active');
            document.getElementById('uploadTab').classList.remove('active');

            if (tab === 'generate') {
                document.getElementById('generateTab').classList.add('active');
            } else {
                document.getElementById('uploadTab').classList.add('active');
            }
        }

        // ========== UPLOAD METHOD SWITCHING ==========
        function switchUploadMethod(method) {
            // Update method buttons
            document.querySelectorAll('.upload-method-btn').forEach(btn => btn.classList.remove('active'));
            event.target.closest('.upload-method-btn').classList.add('active');

            // Show/hide sections
            if (method === 'paste') {
                document.getElementById('pasteSection').style.display = 'block';
                document.getElementById('fileSection').style.display = 'none';
            } else {
                document.getElementById('pasteSection').style.display = 'none';
                document.getElementById('fileSection').style.display = 'block';
            }
        }

        // ========== FILE UPLOAD HANDLING ==========
        let uploadedFileContent = '';

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedFileContent = e.target.result;
                document.getElementById('fileInputLabel').classList.add('has-file');
                document.getElementById('fileName').textContent = `âœ“ ${file.name}`;
                document.getElementById('fileName').style.display = 'block';
                showToast('File loaded successfully!', 'success');
            };
            reader.onerror = function() {
                showToast('Error reading file', 'error');
            };
            reader.readAsText(file);
        }

        // ========== LOAD UPLOADED HTML ==========
        async function loadUploadedHTML() {
            // Get HTML from paste or file
            let html = '';
            const pasteSection = document.getElementById('pasteSection');

            if (pasteSection.style.display !== 'none') {
                html = document.getElementById('htmlInput').value.trim();
            } else {
                html = uploadedFileContent;
            }

            if (!html) {
                showToast('Please paste HTML or upload a file first', 'error');
                return;
            }

            // Validate it's HTML
            if (!html.includes('<') || !html.includes('>')) {
                showToast('Invalid HTML content', 'error');
                return;
            }

            // Show loading
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.querySelector('.loading-text').textContent = 'Loading your HTML...';

            try {
                // Set the HTML
                currentHTML = html;
                currentUsername = 'custom';

                // Try to extract design context from the uploaded HTML
                try {
                    const response = await fetch(`${AI_BASE}/api/build/extract-context`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ html: html })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        designContext = data.design_context;
                        console.log('Extracted design context:', designContext);
                    }
                } catch (e) {
                    console.log('Could not extract design context, will edit without it');
                    designContext = null;
                }

                // Hide welcome screen
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('loadingOverlay').style.display = 'none';

                // Update preview
                updatePreviewFrame(currentHTML);

                // Show toolbar
                document.getElementById('bottomToolbar').classList.add('visible');

                // Update project name
                document.getElementById('projectName').textContent = 'Uploaded Website';

                // Initialize chat session for editing
                chatSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                try {
                    await fetch(`${AI_BASE}/api/chat/init`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: chatSessionId,
                            username: 'custom'
                        })
                    });
                    // Sync the HTML with the chat session
                    await fetch(`${AI_BASE}/api/chat/apply-html`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: chatSessionId,
                            html: currentHTML
                        })
                    });
                } catch (e) {
                    console.log('Chat init error:', e);
                }

                showToast('HTML loaded! Use AI chat to edit.', 'success');

            } catch (error) {
                console.error('Error loading HTML:', error);
                document.getElementById('loadingOverlay').style.display = 'none';
                showToast('Error loading HTML: ' + error.message, 'error');
            }
        }

        // ========== TEMPLATE SELECTION ==========
        function selectTemplate(element) {
            // Remove selected class from all template cards
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('selected');
            });
            // Add selected class to clicked card
            element.classList.add('selected');
            // Update selected template ID
            selectedTemplateId = element.dataset.template;
            console.log('Selected template:', selectedTemplateId);
        }

        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            setupIframeListeners();
        });

        function setupIframeListeners() {
            const iframe = document.getElementById('previewFrame');

            iframe.onload = () => {
                if (!currentHTML) return;

                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

                // Add click listener for element selection
                iframeDoc.addEventListener('click', handleIframeClick);

                // Add double-click for inline editing
                iframeDoc.addEventListener('dblclick', handleIframeDblClick);

                // Add mouseover for hover effects
                iframeDoc.addEventListener('mouseover', handleIframeHover);
                iframeDoc.addEventListener('mouseout', handleIframeMouseOut);

                // Inject edit mode styles
                injectEditStyles(iframeDoc);
            };
        }

        function injectEditStyles(doc) {
            const style = doc.createElement('style');
            style.textContent = `
                .ai-edit-hover {
                    outline: 2px dashed #667eea !important;
                    outline-offset: 2px;
                    cursor: pointer;
                }
                .ai-edit-selected {
                    outline: 2px solid #764ba2 !important;
                    outline-offset: 2px;
                    background: rgba(118, 75, 162, 0.05) !important;
                }
                .ai-editable {
                    transition: outline 0.15s, background 0.15s;
                }
            `;
            doc.head.appendChild(style);

            // Mark editable elements
            const editables = doc.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span, a, button, li');
            editables.forEach(el => el.classList.add('ai-editable'));
        }

        // ========== WEBSITE GENERATION ==========
        async function generateWebsite() {
            const username = document.getElementById('username').value.trim();
            const userPrompt = document.getElementById('userPrompt').value.trim();

            if (!username) {
                showToast('Please enter a username', 'error');
                return;
            }

            currentUsername = username;
            document.getElementById('projectName').textContent = `${username}'s Website`;

            document.getElementById('welcomeScreen').classList.add('hidden');
            document.getElementById('loadingOverlay').classList.add('active');

            try {
                // Initialize chat session
                chatSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                await fetch(`${AI_BASE}/api/chat/init`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: chatSessionId,
                        username: username
                    })
                });

                // Generate website with selected template
                console.log('Generating website with template:', selectedTemplateId);
                const response = await fetch(`${AI_BASE}/api/build/website`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: username,
                        user_prompt: userPrompt || 'Create a professional portfolio website that showcases all my services, testimonials, and badges',
                        template_id: selectedTemplateId
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to generate website');
                }

                const data = await response.json();
                currentHTML = data.html;
                htmlHistory = [currentHTML];
                designContext = data.design_context || null;  // Store design context
                console.log('Design context:', designContext);

                updatePreviewFrame(currentHTML);
                document.getElementById('loadingOverlay').classList.remove('active');
                document.getElementById('bottomToolbar').classList.add('visible');

                // Sync with chat session
                await fetch(`${AI_BASE}/api/chat/apply-html`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: chatSessionId,
                        html: currentHTML
                    })
                });

                // Load components for overlay
                await loadComponents();

                showToast('Website generated successfully!', 'success');

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('loadingOverlay').classList.remove('active');
                document.getElementById('welcomeScreen').classList.remove('hidden');
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        // ========== COMPONENT LOADING ==========
        async function loadComponents() {
            if (!currentHTML) return;

            try {
                const response = await fetch(`${AI_BASE}/api/component/identify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        include_text: true,
                        include_bounds: true
                    })
                });

                const data = await response.json();
                if (data.success) {
                    components = data.components;
                }
            } catch (error) {
                console.error('Failed to load components:', error);
            }
        }

        // ========== IFRAME EVENT HANDLERS ==========
        function handleIframeClick(e) {
            if (!editModeEnabled) return;

            e.preventDefault();
            e.stopPropagation();

            const iframe = document.getElementById('previewFrame');
            const iframeDoc = iframe.contentDocument;

            // Clear previous selection
            iframeDoc.querySelectorAll('.ai-edit-selected').forEach(el => {
                el.classList.remove('ai-edit-selected');
            });

            // Select clicked element
            const target = e.target;
            target.classList.add('ai-edit-selected');
            selectedElement = target;

            // Update context panel
            updateContextPanel(target);

            // Check if element is an image
            const isImage = target.tagName.toLowerCase() === 'img' ||
                           (target.style.backgroundImage && target.style.backgroundImage !== 'none') ||
                           window.getComputedStyle(target).backgroundImage !== 'none';

            // Show appropriate toolbar
            if (isImage || target.tagName.toLowerCase() === 'img') {
                showImageToolbar(e);
            } else {
                showFloatingToolbar(e);
            }
        }

        function handleIframeDblClick(e) {
            if (!editModeEnabled) return;

            e.preventDefault();
            e.stopPropagation();

            const target = e.target;
            if (isEditableElement(target)) {
                openInlineEdit(target, e);
            }
        }

        function handleIframeHover(e) {
            if (!editModeEnabled) return;

            const target = e.target;
            if (isEditableElement(target) && !target.classList.contains('ai-edit-selected')) {
                target.classList.add('ai-edit-hover');
            }
        }

        function handleIframeMouseOut(e) {
            const target = e.target;
            target.classList.remove('ai-edit-hover');
        }

        function isEditableElement(el) {
            const editableTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'SPAN', 'A', 'BUTTON', 'LI', 'DIV', 'SECTION', 'ARTICLE', 'HEADER', 'FOOTER'];
            return editableTags.includes(el.tagName);
        }

        // ========== CONTEXT PANEL ==========
        function updateContextPanel(element) {
            const panel = document.getElementById('contextPanel');
            const elementName = document.getElementById('contextElement');
            const elementText = document.getElementById('contextText');

            panel.classList.add('active');

            // Determine element name
            let name = element.tagName.toLowerCase();
            if (element.id) name = `#${element.id}`;
            else if (element.className) name = `.${element.className.split(' ')[0]}`;

            elementName.textContent = name;
            elementText.textContent = element.textContent?.substring(0, 100) || '';

            selectedComponent = {
                element: element,
                selector: getSelector(element),
                tag: element.tagName.toLowerCase(),
                classes: Array.from(element.classList).filter(c => !c.startsWith('ai-')),
                text: element.textContent?.substring(0, 200),
                parent_selector: element.parentElement ? getSelector(element.parentElement) : null,
                attributes: getElementAttributes(element),
                outer_html: getElementHtml(element),
                color_classes: getColorClasses(element)
            };

            // Open sidebar if not open
            if (!document.getElementById('aiSidebar').classList.contains('open')) {
                toggleAISidebar();
            }
        }

        function getSelector(element) {
            // Build a unique selector for precise targeting
            // Strategy: Include parent context to ensure uniqueness across the document

            if (element.id) return `#${element.id}`;

            const tag = element.tagName.toLowerCase();
            const classes = element.className ?
                element.className.split(' ').filter(c => c && !c.startsWith('ai-') && !c.includes(':')) : [];

            // Build the element's own selector
            let elementSelector = tag;
            if (classes.length > 0) {
                elementSelector += classes.slice(0, 3).map(c => `.${c}`).join('');
            }

            // Get parent context for uniqueness
            const parent = element.parentElement;
            let parentSelector = '';

            if (parent && parent.tagName !== 'BODY' && parent.tagName !== 'HTML') {
                // Try parent's ID first
                if (parent.id) {
                    parentSelector = `#${parent.id}`;
                } else {
                    // Use parent's tag and first meaningful class
                    const parentClasses = parent.className ?
                        parent.className.split(' ').filter(c => c && !c.startsWith('ai-') && !c.includes(':')) : [];

                    if (parentClasses.length > 0) {
                        // Look for semantic class names (section, hero, about, services, etc.)
                        const semanticClass = parentClasses.find(c =>
                            /section|hero|about|service|contact|footer|header|nav|testimonial|pricing|feature/i.test(c)
                        ) || parentClasses[0];
                        parentSelector = `${parent.tagName.toLowerCase()}.${semanticClass}`;
                    } else {
                        parentSelector = parent.tagName.toLowerCase();
                    }
                }
            }

            // Add nth-of-type for elements with siblings of same tag
            let nthSelector = '';
            if (parent) {
                const siblings = Array.from(parent.children);
                const sameTagSiblings = siblings.filter(s => s.tagName === element.tagName);
                if (sameTagSiblings.length > 1) {
                    const index = sameTagSiblings.indexOf(element) + 1;
                    nthSelector = `:nth-of-type(${index})`;
                }
            }

            // Combine for full selector
            const fullSelector = parentSelector
                ? `${parentSelector} > ${elementSelector}${nthSelector}`
                : `${elementSelector}${nthSelector}`;

            // Log the generated selector for debugging
            console.log('Generated selector:', fullSelector, 'for element:', element.outerHTML.substring(0, 100));

            return fullSelector;
        }

        function getElementAttributes(element) {
            const attrs = {};
            const importantAttrs = ['href', 'src', 'alt', 'id', 'data-id', 'class'];
            importantAttrs.forEach(attr => {
                if (element.hasAttribute(attr)) {
                    attrs[attr] = element.getAttribute(attr);
                }
            });
            return attrs;
        }

        // Get element's outer HTML (truncated for large elements)
        function getElementHtml(element) {
            if (!element) return null;
            const html = element.outerHTML;
            // Truncate if too large, but keep enough context
            if (html.length > 2000) {
                return html.substring(0, 2000) + '... (truncated)';
            }
            return html;
        }

        // Extract Tailwind color classes from element
        function getColorClasses(element) {
            if (!element.className) return [];
            const classes = element.className.split(' ');
            const colorPatterns = [
                /^(bg|text|border|ring|shadow)-/,
                /^(from|via|to)-/,  // gradients
                /^(hover:|focus:|active:)?(bg|text|border)-/
            ];
            return classes.filter(c => colorPatterns.some(p => p.test(c)));
        }

        // Build selected element data for API (without DOM element reference)
        function buildSelectedElementData() {
            if (!selectedComponent) return null;
            return {
                selector: selectedComponent.selector,
                tag: selectedComponent.tag,
                classes: selectedComponent.classes,
                text: selectedComponent.text,
                parent_selector: selectedComponent.parent_selector,
                attributes: selectedComponent.attributes,
                outer_html: selectedComponent.outer_html,
                color_classes: selectedComponent.color_classes
            };
        }

        // ========== FLOATING TOOLBAR ==========
        function showFloatingToolbar(e) {
            hideAllToolbars();
            const toolbar = document.getElementById('floatingToolbar');
            const iframe = document.getElementById('previewFrame');
            const iframeRect = iframe.getBoundingClientRect();

            // Position toolbar above the clicked element
            const x = iframeRect.left + e.clientX;
            const y = iframeRect.top + e.clientY - 50;

            toolbar.style.left = `${Math.max(10, Math.min(x - 150, window.innerWidth - 400))}px`;
            toolbar.style.top = `${Math.max(10, y)}px`;
            toolbar.classList.add('visible');
        }

        function showImageToolbar(e) {
            hideAllToolbars();
            const toolbar = document.getElementById('imageToolbar');
            const iframe = document.getElementById('previewFrame');
            const iframeRect = iframe.getBoundingClientRect();

            // Store the selected image element for later use
            lastSelectedImage = selectedElement;
            console.log('Stored lastSelectedImage:', lastSelectedImage);

            // Position toolbar above the clicked element
            const x = iframeRect.left + e.clientX;
            const y = iframeRect.top + e.clientY - 50;

            toolbar.style.left = `${Math.max(10, Math.min(x - 150, window.innerWidth - 350))}px`;
            toolbar.style.top = `${Math.max(10, y)}px`;
            toolbar.classList.add('visible');
        }

        function hideFloatingToolbar() {
            document.getElementById('floatingToolbar').classList.remove('visible');
        }

        function hideAllToolbars() {
            const floatingToolbar = document.getElementById('floatingToolbar');
            const imageToolbar = document.getElementById('imageToolbar');
            const modal = document.getElementById('imageUrlModal');

            if (floatingToolbar) floatingToolbar.classList.remove('visible');
            if (imageToolbar) imageToolbar.classList.remove('visible');
            if (modal) modal.classList.remove('visible');
        }

        // ========== IMAGE EDITING ==========
        let currentImageUrl = '';
        let lastSelectedImage = null;  // Store the last selected image element

        function openImageReplaceChat() {
            console.log('openImageReplaceChat called');

            // Hide image toolbar
            const imageToolbar = document.getElementById('imageToolbar');
            if (imageToolbar) imageToolbar.classList.remove('visible');

            // Use lastSelectedImage if selectedElement is lost
            const imageElement = selectedElement || lastSelectedImage;

            if (!imageElement) {
                showToast('No image selected', 'error');
                return;
            }

            // Store the image for the chat
            selectedElement = imageElement;

            // Get current image URL for context
            let currentUrl = '';
            try {
                if (selectedElement.tagName?.toLowerCase() === 'img') {
                    currentUrl = selectedElement.src || '';
                }
            } catch (e) {
                console.log('Error getting image URL:', e);
            }

            // Open the chat panel
            const chatPanel = document.querySelector('.chat-panel');
            if (chatPanel && chatPanel.classList.contains('collapsed')) {
                toggleChatPanel();
            }

            // Focus on chat input and add helper text
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.value = 'Replace this image with: ';
                chatInput.focus();
                // Move cursor to end
                chatInput.setSelectionRange(chatInput.value.length, chatInput.value.length);
            }

            // Show helper message
            addChatMessage('assistant', `ðŸ“· **Image selected!** Enter the new image URL after "Replace this image with:" and press Enter.\n\nCurrent image: \`${currentUrl.substring(0, 50)}...\``);
        }

        function openImageUrlEdit() {
            // Redirect to chat-based replacement
            openImageReplaceChat();
        }

        function closeImageModal() {
            const modal = document.getElementById('imageUrlModal');
            if (modal) modal.classList.remove('visible');
        }

        function confirmImageUrl() {
            const input = document.getElementById('imageUrlInput');
            const newUrl = input.value.trim();

            if (newUrl && newUrl !== currentImageUrl) {
                closeImageModal();
                replaceImageUrl(newUrl, currentImageUrl);
            } else if (!newUrl) {
                showToast('Please enter a valid URL', 'error');
            } else {
                closeImageModal();
            }
        }

        // Close modal on click outside or Escape key (with null checks)
        (function() {
            const modal = document.getElementById('imageUrlModal');
            const input = document.getElementById('imageUrlInput');

            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === this) closeImageModal();
                });
            }

            if (input) {
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        confirmImageUrl();
                    } else if (e.key === 'Escape') {
                        closeImageModal();
                    }
                });
            }
        })();

        async function replaceImageUrlDirect(newUrl, oldUrl) {
            // Validate URL
            try {
                new URL(newUrl);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }

            showToast('Replacing image...', '');
            htmlHistory.push(currentHTML);

            console.log('Replacing image URL directly');
            console.log('Old URL:', oldUrl);
            console.log('New URL:', newUrl);

            let modified = false;

            // Method 1: Direct string replacement if we have the old URL
            if (oldUrl && currentHTML.includes(oldUrl)) {
                currentHTML = currentHTML.split(oldUrl).join(newUrl);
                modified = true;
                console.log('Replaced via direct string match');
            }

            // Method 2: If direct replacement didn't work, try regex for src attribute
            if (!modified && selectedElement?.tagName?.toLowerCase() === 'img') {
                // Extract a unique identifier from the image (like alt text or class)
                const alt = selectedElement.alt || '';
                const className = selectedElement.className || '';

                if (alt) {
                    // Find image by alt attribute and replace src
                    const regex = new RegExp(`(<img[^>]*alt=["']${alt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}["'][^>]*src=["'])[^"']+["']`, 'gi');
                    const newHTML = currentHTML.replace(regex, `$1${newUrl}"`);
                    if (newHTML !== currentHTML) {
                        currentHTML = newHTML;
                        modified = true;
                        console.log('Replaced via alt attribute match');
                    }
                }

                // Also try src pattern
                if (!modified) {
                    const regex = new RegExp(`(<img[^>]*src=["'])[^"']+["']([^>]*alt=["']${alt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}["'])`, 'gi');
                    const newHTML = currentHTML.replace(regex, `$1${newUrl}"$2`);
                    if (newHTML !== currentHTML) {
                        currentHTML = newHTML;
                        modified = true;
                        console.log('Replaced via src+alt pattern');
                    }
                }
            }

            // Method 3: Last resort - use AI
            if (!modified) {
                console.log('Direct replacement failed, using AI');
                try {
                    const instruction = selectedElement?.tagName?.toLowerCase() === 'img'
                        ? `Change the src attribute of the selected image to "${newUrl}"`
                        : `Change the background image of this element to url("${newUrl}")`;

                    const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            html: currentHTML,
                            edit_instruction: instruction,
                            design_context: designContext,
                            selected_element: buildSelectedElementData()
                        })
                    });

                    const data = await response.json();
                    if (data.html) {
                        currentHTML = data.html;
                        modified = true;
                    } else {
                        showToast('Failed to replace image', 'error');
                        return;
                    }
                } catch (error) {
                    console.error('AI replacement failed:', error);
                    showToast('Failed to replace image', 'error');
                    return;
                }
            }

            if (modified) {
                updatePreviewFrame(currentHTML);
                await syncHTML();
                showToast('Image replaced!', 'success');
            }
        }

        async function replaceImageUrl(newUrl, oldUrl) {
            // Wrapper that calls the direct method
            await replaceImageUrlDirect(newUrl, oldUrl);
        }

        function cancelImageUrlEdit() {
            closeImageModal();
        }

        async function saveImageUrl() {
            const input = document.getElementById('imageUrlInput');
            const newUrl = input.value.trim();

            if (!newUrl || !selectedElement) {
                showToast('Please enter a valid URL', 'error');
                return;
            }

            // Validate URL format
            try {
                new URL(newUrl);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }

            htmlHistory.push(currentHTML);

            if (selectedElement.tagName.toLowerCase() === 'img') {
                // Direct image element
                const oldSrc = selectedElement.src;
                selectedElement.src = newUrl;

                // Update currentHTML
                currentHTML = currentHTML.replace(
                    new RegExp(`src=["']${escapeRegExp(oldSrc)}["']`, 'g'),
                    `src="${newUrl}"`
                );
            } else {
                // Background image
                const oldBg = window.getComputedStyle(selectedElement).backgroundImage;
                selectedElement.style.backgroundImage = `url('${newUrl}')`;

                // For background images, we need to update via the editing agent
                try {
                    const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            html: currentHTML,
                            edit_instruction: `Change the background image of the element "${selectedComponent?.selector}" to "${newUrl}"`,
                            design_context: designContext,
                            selected_element: buildSelectedElementData()
                        })
                    });

                    const data = await response.json();
                    if (data.html) {
                        currentHTML = data.html;
                    }
                } catch (error) {
                    console.error('Failed to update background image:', error);
                }
            }

            updatePreviewFrame(currentHTML);
            await syncHTML();
            cancelImageUrlEdit();
            showToast('Image replaced!', 'success');
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        async function imageAction(action) {
            if (!selectedElement || !selectedComponent) {
                showToast('Please select an image first', 'error');
                return;
            }

            hideAllToolbars();

            let instruction = '';
            switch (action) {
                case 'resize':
                    instruction = `Make this image slightly smaller (reduce by about 20%)`;
                    break;
                case 'round':
                    instruction = `Add rounded corners to this image (use rounded-lg or rounded-xl class)`;
                    break;
                case 'remove':
                    instruction = `Remove this image element completely`;
                    break;
            }

            if (!instruction) return;

            showToast(`Applying ${action}...`, '');

            try {
                const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        edit_instruction: instruction,
                        design_context: designContext,
                        selected_element: buildSelectedElementData()
                    })
                });

                const data = await response.json();

                if (data.html) {
                    htmlHistory.push(currentHTML);
                    currentHTML = data.html;
                    updatePreviewFrame(currentHTML);
                    await syncHTML();
                    showToast('Image updated!', 'success');
                } else {
                    showToast('Edit failed', 'error');
                }
            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        // ========== INLINE EDITING ==========
        function openInlineEdit(element, e) {
            const container = document.getElementById('inlineEditContainer');
            const textarea = document.getElementById('inlineEditText');
            const iframe = document.getElementById('previewFrame');
            const iframeRect = iframe.getBoundingClientRect();

            textarea.value = element.textContent;

            const x = iframeRect.left + e.clientX;
            const y = iframeRect.top + e.clientY + 20;

            container.style.left = `${Math.max(10, Math.min(x - 150, window.innerWidth - 350))}px`;
            container.style.top = `${Math.max(10, y)}px`;
            container.classList.add('active');

            textarea.focus();
            textarea.select();

            hideAllToolbars();
        }

        function cancelInlineEdit() {
            document.getElementById('inlineEditContainer').classList.remove('active');
        }

        async function saveInlineEdit() {
            const newText = document.getElementById('inlineEditText').value;

            if (selectedElement && newText) {
                // Save to history
                htmlHistory.push(currentHTML);

                // Update element
                selectedElement.textContent = newText;

                // Get updated HTML
                const iframe = document.getElementById('previewFrame');
                const iframeDoc = iframe.contentDocument;
                currentHTML = '<!DOCTYPE html>' + iframeDoc.documentElement.outerHTML;

                // Sync with backend
                await syncHTML();

                showToast('Text updated', 'success');
            }

            cancelInlineEdit();
        }

        // ========== DIRECT TEXT EDIT ==========
        async function applyDirectTextEdit() {
            const input = document.getElementById('directEditInput');
            const newText = input.value.trim();

            if (!newText) {
                showToast('Please enter text to replace', 'error');
                return;
            }

            if (!selectedElement) {
                showToast('Please select an element first', 'error');
                return;
            }

            // Save to history
            htmlHistory.push(currentHTML);

            // Update the element text directly
            selectedElement.textContent = newText;

            // Get updated HTML from iframe
            const iframe = document.getElementById('previewFrame');
            const iframeDoc = iframe.contentDocument;
            currentHTML = '<!DOCTYPE html>' + iframeDoc.documentElement.outerHTML;

            // Sync with backend
            await syncHTML();

            // Update context panel to show new text
            document.getElementById('contextText').textContent = newText.substring(0, 100);

            // Clear input
            input.value = '';

            showToast('Text replaced successfully!', 'success');
        }

        // ========== TOOLBAR ACTIONS ==========
        async function toolbarAction(action) {
            if (!selectedElement || !selectedComponent) {
                showToast('Please select an element first', 'error');
                return;
            }

            hideAllToolbars();
            showToast(`Applying ${action}...`, '');

            try {
                let instruction = '';
                switch (action) {
                    case 'expand':
                        instruction = `Expand and add more detail to this text: "${selectedComponent.text}"`;
                        break;
                    case 'condense':
                        instruction = `Make this text more concise: "${selectedComponent.text}"`;
                        break;
                    case 'engaging':
                        instruction = `Make this text more engaging and compelling: "${selectedComponent.text}"`;
                        break;
                    case 'rephrase':
                        instruction = `Rephrase this text differently: "${selectedComponent.text}"`;
                        break;
                    case 'fix':
                        instruction = `Fix any grammar or spelling issues in: "${selectedComponent.text}"`;
                        break;
                    case 'delete':
                        instruction = `Remove this element completely from the page`;
                        break;
                }

                const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        edit_instruction: `For the element "${selectedComponent.selector}": ${instruction}`,
                        design_context: designContext,
                        selected_element: buildSelectedElementData()
                    })
                });

                const data = await response.json();

                if (data.html) {
                    htmlHistory.push(currentHTML);
                    currentHTML = data.html;
                    updatePreviewFrame(currentHTML);
                    await syncHTML();
                    showToast('Edit applied!', 'success');
                } else {
                    showToast('Edit failed', 'error');
                }
            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        // Apply quick color from toolbar palette
        async function applyQuickColor(color) {
            if (!selectedElement || !selectedComponent) {
                showToast('Please select an element first', 'error');
                return;
            }

            hideAllToolbars();
            showToast(`Applying color...`, '');

            try {
                const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        edit_instruction: `For the element "${selectedComponent.selector}": Change the text color to ${color}. Apply this color directly to the element using inline style or by updating its CSS.`,
                        design_context: designContext,
                        selected_element: buildSelectedElementData()
                    })
                });

                const data = await response.json();

                if (data.html) {
                    htmlHistory.push(currentHTML);
                    currentHTML = data.html;
                    updatePreviewFrame(currentHTML);
                    await syncHTML();
                    showToast(`Color applied!`, 'success');
                } else {
                    showToast('Failed to apply color', 'error');
                }
            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        // ========== QUICK ACTIONS ==========
        async function quickAction(action) {
            if (action === 'polish') {
                await polishAll();
                return;
            }

            if (!selectedComponent) {
                showToast('Please select an element first', 'error');
                return;
            }

            await toolbarAction(action);
        }

        async function polishAll() {
            showToast('Restructuring layout and spacing...', '');

            try {
                const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        edit_instruction: `CRITICAL: Fix the website layout WITHOUT changing any text content, colors, or design:

## WHAT TO FIX:
1. Text overflow issues - if any text is breaking out of its container, add appropriate Tailwind classes:
   - Use 'break-words' or 'overflow-hidden' for containers
   - Use 'truncate' if text should be clipped with ellipsis
   - Use 'whitespace-normal' to allow text wrapping

2. Container width issues - ensure containers constrain their content:
   - Add 'max-w-full' or specific max-width classes
   - Use 'w-full' with parent constraints

3. Spacing problems - fix padding and margins:
   - Adjust p-* and m-* classes for proper spacing
   - Ensure consistent gaps between elements (gap-4, gap-6, etc.)

4. Flex/Grid layout fixes:
   - Add 'flex-wrap' if items should wrap
   - Use 'items-start' or 'items-center' for alignment
   - Adjust 'justify-*' for horizontal distribution

## WHAT NOT TO CHANGE:
- Do NOT change any text content (words, sentences)
- Do NOT change colors (bg-*, text-*, border-*)
- Do NOT change fonts or font sizes
- Do NOT remove any elements
- Do NOT change images or links

Use find_and_replace or modify_class to make these structural fixes.`,
                        design_context: designContext,
                        use_browserbase: true
                    })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const data = await response.json();

                if (data.success && data.html && data.html !== currentHTML) {
                    htmlHistory.push(currentHTML);
                    currentHTML = data.html;
                    updatePreviewFrame(currentHTML);
                    updatePreviewFrameNew(currentHTML);
                    await syncHTML();
                    showToast('Layout fixed!', 'success');
                } else if (data.html === currentHTML) {
                    showToast('No layout issues found', '');
                } else {
                    showToast(data.error || 'Could not fix layout', 'error');
                }
            } catch (error) {
                console.error('Fix layout error:', error);
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        function undoAction() {
            if (htmlHistory.length > 1) {
                htmlHistory.pop();
                currentHTML = htmlHistory[htmlHistory.length - 1];
                // Update both old and new preview frames (whichever is active)
                updatePreviewFrame(currentHTML);
                updatePreviewFrameNew(currentHTML);
                syncHTML();
                showToast('Undone', 'success');
            } else {
                showToast('Nothing to undo', '');
            }
        }

        // ========== EDIT MODE ==========
        function toggleEditMode() {
            editModeEnabled = !editModeEnabled;
            const btn = document.getElementById('editModeBtn');
            btn.classList.toggle('active', editModeEnabled);

            if (!editModeEnabled) {
                hideAllToolbars();
                cancelInlineEdit();

                // Clear selections in iframe
                const iframe = document.getElementById('previewFrame');
                const iframeDoc = iframe.contentDocument;
                if (iframeDoc) {
                    iframeDoc.querySelectorAll('.ai-edit-selected, .ai-edit-hover').forEach(el => {
                        el.classList.remove('ai-edit-selected', 'ai-edit-hover');
                    });
                }

                document.getElementById('contextPanel').classList.remove('active');
            }

            showToast(editModeEnabled ? 'Edit mode enabled - click elements to select' : 'Edit mode disabled', '');
        }

        // ========== AI SIDEBAR ==========
        function toggleAISidebar() {
            const sidebar = document.getElementById('aiSidebar');
            sidebar.classList.toggle('open');
        }

        function openAIEdit() {
            hideAllToolbars();
            toggleAISidebar();

            if (selectedComponent) {
                document.getElementById('chatInput').value = `Edit the ${selectedComponent.selector}: `;
                document.getElementById('chatInput').focus();
            }
        }

        // ========== CHAT ==========
        function handleChatKeydown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatMessage();
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (!message) return;

            addChatMessage('user', message);
            input.value = '';

            // If website exists, send ALL messages to edit API directly
            // The AI editing agent is smart enough to handle any instruction
            const hasWebsite = !!currentHTML && currentHTML.length > 100;

            console.log('=== SEND CHAT MESSAGE ===');
            console.log('Message:', message);
            console.log('hasWebsite:', hasWebsite);

            if (hasWebsite) {
                console.log('>>> DIRECT EDIT MODE - sending to /api/edit/optimized');
                // Direct edit - bypass chatbot and call edit API
                const typingId = addChatMessage('assistant', 'ðŸ”„ Applying edit...', false);

                try {
                    document.getElementById('previewFrame').style.opacity = '0.5';

                    const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            html: currentHTML,
                            edit_instruction: message,
                            design_context: designContext,
                            selected_element: buildSelectedElementData()
                        })
                    });

                    console.log('Edit response status:', response.status);
                    const data = await response.json();
                    console.log('Edit response data:', JSON.stringify(data).substring(0, 500));
                    document.getElementById('previewFrame').style.opacity = '1';

                    if (data.success && data.html) {
                        console.log('Edit SUCCESS - HTML changed, length:', data.html.length);
                        htmlHistory.push(currentHTML);
                        currentHTML = data.html;
                        updatePreviewFrame(currentHTML);
                        await syncHTML();
                        updateChatMessage(typingId, `âœ… Done! ${data.summary || 'Edit applied successfully.'}`);
                        showToast('Edit applied!', 'success');
                    } else {
                        updateChatMessage(typingId, `âŒ Edit failed: ${data.error || 'Unknown error'}`);
                        showToast('Edit failed', 'error');
                    }
                } catch (error) {
                    document.getElementById('previewFrame').style.opacity = '1';
                    updateChatMessage(typingId, `âŒ Error: ${error.message}`);
                    showToast('Edit failed', 'error');
                }
                return;
            }

            // Regular chat message - use chatbot
            const typingId = addChatMessage('assistant', '', true);

            try {
                const response = await fetch(`${AI_BASE}/api/chat/send`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: chatSessionId,
                        message: message,
                        context: {
                            selected_component: selectedComponent?.selector,
                            selected_element: buildSelectedElementData(),
                            has_html: !!currentHTML
                        }
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantMessage = '';
                let buffer = '';  // Buffer for incomplete lines

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');

                    // Keep the last potentially incomplete line in the buffer
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (!jsonStr) continue;
                                const data = JSON.parse(jsonStr);
                                console.log('SSE event:', data.type, data.type === 'actions' ? JSON.stringify(data.items) : '');
                                if (data.type === 'text') {
                                    assistantMessage += data.content;
                                    updateChatMessage(typingId, assistantMessage);
                                } else if (data.type === 'actions') {
                                    console.log('>>> ACTIONS RECEIVED:', JSON.stringify(data.items));
                                    await handleChatActions(data.items);
                                }
                            } catch (e) {
                                console.log('SSE parse error:', e.message, 'line:', line.substring(0, 100));
                            }
                        }
                    }
                }

                // Process any remaining buffer
                if (buffer.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(buffer.slice(6).trim());
                        if (data.type === 'actions') {
                            console.log('>>> FINAL ACTIONS:', JSON.stringify(data.items));
                            await handleChatActions(data.items);
                        }
                    } catch (e) {}
                }

                if (!assistantMessage) {
                    removeChatMessage(typingId);
                }

            } catch (error) {
                updateChatMessage(typingId, 'Sorry, I encountered an error.');
            }
        }

        function addChatMessage(role, content, isTyping = false) {
            const container = document.getElementById('chatMessages');
            const messageId = 'msg-' + Date.now();

            const messageEl = document.createElement('div');
            messageEl.id = messageId;
            messageEl.className = `chat-message ${role}`;

            const contentEl = document.createElement('div');
            contentEl.className = 'chat-message-content';

            if (isTyping) {
                contentEl.innerHTML = `
                    <div class="typing-message">
                        <div class="typing-avatar">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a2 2 0 0 1 0 4h-1v1a2 2 0 0 1-2 2h-1v1a2 2 0 0 1-4 0v-1h-4v1a2 2 0 0 1-4 0v-1H5a2 2 0 0 1-2-2v-1H2a2 2 0 0 1 0-4h1a7 7 0 0 1 7-7h1V5.73A2 2 0 0 1 10 4a2 2 0 0 1 2-2z"/>
                                <circle cx="8" cy="14" r="1"/><circle cx="16" cy="14" r="1"/>
                            </svg>
                        </div>
                        <div class="typing-content">
                            <div class="typing-indicator">
                                <div class="typing-dots">
                                    <span></span><span></span><span></span>
                                </div>
                            </div>
                            <div class="typing-status">
                                <div class="typing-spinner"></div>
                                <span class="typing-status-text">Processing your request...</span>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                contentEl.innerHTML = formatMessage(content);
            }

            messageEl.appendChild(contentEl);
            container.appendChild(messageEl);
            container.scrollTop = container.scrollHeight;

            return messageId;
        }

        function updateChatMessage(id, content) {
            const el = document.getElementById(id);
            if (el) {
                el.querySelector('.chat-message-content').innerHTML = formatMessage(content);
                document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            }
        }

        function removeChatMessage(id) {
            const el = document.getElementById(id);
            if (el) el.remove();
        }

        // Update typing indicator status text
        function updateTypingStatus(id, statusText) {
            const el = document.getElementById(id);
            if (el) {
                const statusEl = el.querySelector('.typing-status-text');
                if (statusEl) {
                    statusEl.textContent = statusText;
                }
            }
        }

        function formatMessage(content) {
            return content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n/g, '<br>')
                .replace(/\[ACTION:.*?\]/g, '');
        }

        function useSuggestion(text) {
            document.getElementById('chatInput').value = text;
            sendChatMessage();
        }

        async function handleChatActions(actions) {
            console.log('=== handleChatActions START ===');
            console.log('Actions received:', JSON.stringify(actions));
            console.log('currentHTML exists:', !!currentHTML, 'length:', currentHTML?.length);
            console.log('Current HTML exists:', !!currentHTML, 'length:', currentHTML?.length);

            if (!actions || actions.length === 0) {
                console.log('No actions to process');
                return;
            }

            for (const action of actions) {
                console.log('Processing action:', JSON.stringify(action));
                console.log('Action type:', action.type, 'Expected: EDIT_WEBSITE');
                console.log('Type match:', action.type === 'EDIT_WEBSITE');

                if (action.type === 'EDIT_WEBSITE' && currentHTML) {
                    showToast('ðŸ”„ Applying edit: ' + action.data.substring(0, 50) + '...', '');
                    // Add visual loading indicator
                    document.getElementById('previewFrame').style.opacity = '0.5';

                    try {
                        console.log('Sending edit request:', action.data);
                        console.log('Sending HTML length:', currentHTML.length);
                        const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                html: currentHTML,
                                edit_instruction: action.data,
                                design_context: designContext,
                                selected_element: buildSelectedElementData()
                            })
                        });

                        console.log('Edit response status:', response.status);
                        const data = await response.json();
                        console.log('Edit response:', { success: data.success, hasHtml: !!data.html, htmlLength: data.html?.length });
                        console.log('Edit response summary:', data.summary || 'none');

                        if (data.html) {
                            const htmlChanged = data.html !== currentHTML;
                            console.log('HTML changed:', htmlChanged);
                            console.log('Old HTML length:', currentHTML.length);
                            console.log('New HTML length:', data.html.length);

                            // Debug: show first 500 chars diff
                            if (htmlChanged) {
                                for (let i = 0; i < Math.min(data.html.length, currentHTML.length); i++) {
                                    if (data.html[i] !== currentHTML[i]) {
                                        console.log('First diff at index:', i);
                                        console.log('Old:', currentHTML.substring(i, i+100));
                                        console.log('New:', data.html.substring(i, i+100));
                                        break;
                                    }
                                }
                            }

                            htmlHistory.push(currentHTML);
                            currentHTML = data.html;

                            // Force iframe refresh by replacing it
                            updatePreviewFrame(currentHTML);

                            // Reset opacity (in case old frame reference still exists)
                            const frame = document.getElementById('previewFrame');
                            if (frame) frame.style.opacity = '1';

                            await syncHTML();
                            showToast(htmlChanged ? 'âœ… Edit applied!' : 'âš ï¸ No changes made', htmlChanged ? 'success' : '');
                        } else {
                            console.log('No HTML in response, data:', JSON.stringify(data).substring(0, 500));
                            document.getElementById('previewFrame').style.opacity = '1';
                            showToast('âŒ Edit returned no HTML', 'error');
                        }
                    } catch (error) {
                        console.error('Edit error:', error);
                        document.getElementById('previewFrame').style.opacity = '1';
                        showToast('âŒ Edit failed: ' + error.message, 'error');
                    }
                }
            }
        }

        // ========== SYNC ==========
        async function syncHTML() {
            if (chatSessionId && currentHTML) {
                try {
                    await fetch(`${AI_BASE}/api/chat/apply-html`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: chatSessionId,
                            html: currentHTML
                        })
                    });
                } catch (e) {}
            }
        }

        // ========== DOWNLOAD ==========
        function downloadHTML() {
            if (!currentHTML) {
                showToast('No website to download', 'error');
                return;
            }

            const blob = new Blob([currentHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentUsername || 'website'}_portfolio.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('Downloaded!', 'success');
        }

        // ========== RESET ==========
        function resetForm() {
            document.getElementById('welcomeScreen').classList.remove('hidden');
            document.getElementById('bottomToolbar').classList.remove('visible');
            document.getElementById('aiSidebar').classList.remove('open');
            document.getElementById('username').value = '';
            document.getElementById('userPrompt').value = '';
            document.getElementById('previewFrame').srcdoc = '';
            document.getElementById('projectName').textContent = 'New Website';

            currentHTML = '';
            currentUsername = '';
            htmlHistory = [];
            editModeEnabled = false;
            selectedElement = null;
            selectedComponent = null;

            // Reset template selection to default
            selectedTemplateId = 'modern-minimal';
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('selected');
                if (card.dataset.template === 'modern-minimal') {
                    card.classList.add('selected');
                }
            });

            document.getElementById('editModeBtn').classList.remove('active');
            document.getElementById('contextPanel').classList.remove('active');
            hideAllToolbars();
            cancelInlineEdit();
        }

        // ========== TOAST ==========
        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast visible';
            if (type) toast.classList.add(type);

            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2500);
        }

        // Button loading state helpers
        function setButtonLoading(button, isLoading) {
            if (isLoading) {
                button.classList.add('btn-loading');
                button.disabled = true;
            } else {
                button.classList.remove('btn-loading');
                button.disabled = false;
            }
        }

        // Show success animation on element
        function showSuccessPulse(element) {
            element.classList.add('success-pulse');
            setTimeout(() => element.classList.remove('success-pulse'), 600);
        }

        // Animate element entry
        function animateEntry(element, animationType = 'fade') {
            element.classList.add(`${animationType}-enter`);
            requestAnimationFrame(() => {
                element.classList.add(`${animationType}-enter-active`);
                element.classList.remove(`${animationType}-enter`);
            });
            setTimeout(() => {
                element.classList.remove(`${animationType}-enter-active`);
            }, 300);
        }

        // ========== DEVICE PREVIEW MODES ==========
        function setDeviceMode(mode) {
            currentDeviceMode = mode;

            // Update button states
            document.querySelectorAll('.device-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            // Update canvas wrapper
            const wrapper = document.getElementById('newCanvasWrapper');
            if (!wrapper) return;

            wrapper.classList.remove('tablet-mode', 'mobile-mode');

            if (mode === 'tablet') {
                wrapper.classList.add('tablet-mode');
            } else if (mode === 'mobile') {
                wrapper.classList.add('mobile-mode');
            }

            showToast(`${mode.charAt(0).toUpperCase() + mode.slice(1)} view`, 'success');
        }

        // ========== ZOOM CONTROLS ==========
        function adjustZoom(delta) {
            currentZoom = Math.max(25, Math.min(200, currentZoom + delta));
            applyZoom();
        }

        function resetZoom() {
            currentZoom = 100;
            applyZoom();
        }

        function applyZoom() {
            const wrapper = document.getElementById('newCanvasWrapper');
            const iframe = wrapper?.querySelector('iframe');

            if (iframe) {
                iframe.style.transform = `scale(${currentZoom / 100})`;
                iframe.style.transformOrigin = 'top left';
                iframe.style.width = `${100 / (currentZoom / 100)}%`;
                iframe.style.height = `${100 / (currentZoom / 100)}%`;
            }

            document.getElementById('zoomLevel').textContent = `${currentZoom}%`;
        }

        // ========== SUGGESTION CHIPS ==========
        const DEFAULT_SUGGESTIONS = [
            { icon: 'ðŸŽ¨', text: 'Change colors', prompt: 'Change the color scheme to ' },
            { icon: 'ðŸ“', text: 'Edit text', prompt: 'Change the text to ' },
            { icon: 'âž•', text: 'Add section', prompt: 'Add a new section for ' },
            { icon: 'âœ¨', text: 'Make it modern', prompt: 'Make this design more modern and appealing' },
            { icon: 'ðŸ“±', text: 'Mobile friendly', prompt: 'Make this more mobile responsive' }
        ];

        const ELEMENT_SUGGESTIONS = {
            'h1': [
                { icon: 'ðŸ“', text: 'Resize', prompt: 'Make this heading larger' },
                { icon: 'ðŸŽ¨', text: 'Color', prompt: 'Change this heading color to ' },
                { icon: 'âœï¸', text: 'Edit', prompt: 'Change this heading text to ' }
            ],
            'h2': [
                { icon: 'ðŸ“', text: 'Resize', prompt: 'Make this heading larger' },
                { icon: 'ðŸŽ¨', text: 'Color', prompt: 'Change this heading color to ' },
                { icon: 'âœï¸', text: 'Edit', prompt: 'Change this heading text to ' }
            ],
            'img': [
                { icon: 'ðŸ”„', text: 'Replace', prompt: 'Replace this image with URL: ' },
                { icon: 'ðŸ“', text: 'Resize', prompt: 'Make this image larger' },
                { icon: 'ðŸ”˜', text: 'Round corners', prompt: 'Add rounded corners to this image' },
                { icon: 'ðŸ—‘ï¸', text: 'Remove', prompt: 'Remove this image' }
            ],
            'button': [
                { icon: 'ðŸŽ¨', text: 'Style', prompt: 'Change this button style to ' },
                { icon: 'ðŸ“', text: 'Text', prompt: 'Change button text to ' },
                { icon: 'ðŸ“', text: 'Size', prompt: 'Make this button larger' }
            ],
            'p': [
                { icon: 'âœï¸', text: 'Edit', prompt: 'Change this text to ' },
                { icon: 'ðŸ“', text: 'Expand', prompt: 'Expand this text with more details' },
                { icon: 'ðŸŽ¨', text: 'Color', prompt: 'Change this text color to ' }
            ],
            'section': [
                { icon: 'ðŸŽ¨', text: 'Background', prompt: 'Change this section background to ' },
                { icon: 'ðŸ“', text: 'Spacing', prompt: 'Add more padding to this section' },
                { icon: 'ðŸ—‘ï¸', text: 'Remove', prompt: 'Remove this entire section' }
            ],
            'div': [
                { icon: 'ðŸŽ¨', text: 'Style', prompt: 'Change the style of this element to ' },
                { icon: 'ðŸ“', text: 'Layout', prompt: 'Adjust the layout of this element' }
            ]
        };

        function updateSuggestionChips() {
            const container = document.getElementById('suggestionChips');
            if (!container) return;

            let suggestions = [...DEFAULT_SUGGESTIONS];

            // Add element-specific suggestions if an element is selected
            if (selectedComponent && selectedComponent.tag) {
                const tag = selectedComponent.tag.toLowerCase();
                const elementSuggestions = ELEMENT_SUGGESTIONS[tag];
                if (elementSuggestions) {
                    suggestions = [...elementSuggestions, ...DEFAULT_SUGGESTIONS.slice(0, 2)];
                }
            }

            // Limit to 5 suggestions
            suggestions = suggestions.slice(0, 5);

            container.innerHTML = suggestions.map((s, i) => `
                <button class="suggestion-chip" onclick="useSuggestionChip('${s.prompt.replace(/'/g, "\\'")}')" style="animation-delay: ${i * 40}ms;">
                    <span class="suggestion-chip-icon">${s.icon}</span>
                    ${s.text}
                </button>
            `).join('');
        }

        function useSuggestionChip(prompt) {
            const input = document.getElementById('chatInputNew');
            if (input) {
                input.value = prompt;
                input.focus();
                input.setSelectionRange(input.value.length, input.value.length);
            }
        }

        // Initialize suggestion chips on page load
        document.addEventListener('DOMContentLoaded', updateSuggestionChips);

        // ========== KEYBOARD SHORTCUTS ==========
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in input/textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    if (e.key === 'Escape') {
                        e.target.blur();
                    }
                    return;
                }

                const ctrl = e.ctrlKey || e.metaKey;

                // Ctrl+Z - Undo
                if (ctrl && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoAction();
                }

                // Ctrl+S - Download
                if (ctrl && e.key === 's') {
                    e.preventDefault();
                    downloadHTML();
                }

                // Ctrl+1 - Desktop mode
                if (ctrl && e.key === '1') {
                    e.preventDefault();
                    setDeviceMode('desktop');
                }

                // Ctrl+2 - Tablet mode
                if (ctrl && e.key === '2') {
                    e.preventDefault();
                    setDeviceMode('tablet');
                }

                // Ctrl+3 - Mobile mode
                if (ctrl && e.key === '3') {
                    e.preventDefault();
                    setDeviceMode('mobile');
                }

                // Ctrl+H - Toggle history
                if (ctrl && e.key === 'h') {
                    e.preventDefault();
                    toggleHistoryPanel();
                }

                // Escape - Close panels, clear selection
                if (e.key === 'Escape') {
                    escapeAction();
                }

                // Ctrl+/ - Show shortcuts help
                if (ctrl && e.key === '/') {
                    e.preventDefault();
                    showShortcutsHelp();
                }
            });
        }

        function escapeAction() {
            // Hide toolbars
            const toolbar = document.getElementById('floatingToolbar');
            if (toolbar) toolbar.style.display = 'none';

            const imageToolbar = document.getElementById('imageToolbar');
            if (imageToolbar) imageToolbar.style.display = 'none';

            // Close history panel
            const historyPanel = document.getElementById('historyPanel');
            if (historyPanel) historyPanel.classList.remove('open');

            // Close any popups
            document.querySelectorAll('.ai-text-selection-popup, .ai-inline-edit-popup').forEach(p => p.remove());

            // Clear selection in preview
            const iframe = document.querySelector('.canvas-wrapper iframe');
            if (iframe?.contentDocument) {
                iframe.contentDocument.querySelectorAll('.ai-edit-selected').forEach(el => {
                    el.classList.remove('ai-edit-selected');
                });
            }

            selectedElement = null;
            selectedComponent = null;
            updateSuggestionChips();
        }

        function showShortcutsHelp() {
            const shortcuts = [
                { key: 'Ctrl + Z', desc: 'Undo last change' },
                { key: 'Ctrl + S', desc: 'Download HTML' },
                { key: 'Ctrl + 1', desc: 'Desktop view' },
                { key: 'Ctrl + 2', desc: 'Tablet view' },
                { key: 'Ctrl + 3', desc: 'Mobile view' },
                { key: 'Ctrl + H', desc: 'Toggle history' },
                { key: 'Escape', desc: 'Close panels / Clear selection' },
                { key: 'Ctrl + /', desc: 'Show this help' }
            ];

            const html = shortcuts.map(s => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #2a2a2a;">
                    <span style="color: #ccc;">${s.desc}</span>
                    <kbd style="background: #2a2a2a; padding: 4px 10px; border-radius: 6px; font-size: 12px; color: #888; font-family: monospace;">${s.key}</kbd>
                </div>
            `).join('');

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'shortcuts-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            modal.innerHTML = `
                <div style="background: #1a1a1a; border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; border: 1px solid #2a2a2a;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #fff; font-size: 16px;">Keyboard Shortcuts</h3>
                        <button onclick="this.closest('.shortcuts-modal').remove()" style="background: #2a2a2a; border: none; width: 28px; height: 28px; border-radius: 6px; color: #888; cursor: pointer; font-size: 16px;">Ã—</button>
                    </div>
                    ${html}
                </div>
            `;
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
            document.body.appendChild(modal);
        }

        // Initialize keyboard shortcuts
        document.addEventListener('DOMContentLoaded', setupKeyboardShortcuts);

        // ========== HISTORY TIMELINE ==========
        function toggleHistoryPanel() {
            const panel = document.getElementById('historyPanel');
            panel.classList.toggle('open');

            if (panel.classList.contains('open')) {
                renderHistoryTimeline();
            }
        }

        function addToHistory(description = 'Edit', html = null) {
            historyMetadata.push({
                timestamp: new Date(),
                description: description,
                html: html || currentHTML
            });

            updateHistoryBadge();
        }

        function updateHistoryBadge() {
            const badge = document.getElementById('historyBadge');
            if (badge) {
                badge.textContent = historyMetadata.length;
                badge.setAttribute('data-count', historyMetadata.length);
            }
        }

        function renderHistoryTimeline() {
            const container = document.getElementById('historyTimeline');
            if (!container) return;

            if (historyMetadata.length === 0) {
                container.innerHTML = '<div class="history-empty">Make some edits to see version history here.</div>';
                return;
            }

            container.innerHTML = historyMetadata.map((item, index) => {
                const isLatest = index === historyMetadata.length - 1;
                const timeStr = item.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const iframeId = `history-iframe-${index}`;

                return `
                    <div class="history-item ${isLatest ? 'current' : ''}" data-index="${index}">
                        <div class="history-item-time">${timeStr}</div>
                        <div class="history-item-desc">${item.description}</div>
                        <div class="history-item-thumb" onclick="previewHistoryItem(${index})">
                            <iframe id="${iframeId}"></iframe>
                        </div>
                        <div class="history-item-actions">
                            <button class="history-action-btn" onclick="previewHistoryItem(${index})">Preview</button>
                            ${!isLatest ? `<button class="history-action-btn restore" onclick="restoreHistoryItem(${index})">Restore</button>` : ''}
                        </div>
                    </div>
                `;
            }).reverse().join('');

            // Load thumbnails
            setTimeout(() => {
                historyMetadata.forEach((item, index) => {
                    const iframe = document.getElementById(`history-iframe-${index}`);
                    if (iframe) {
                        const container = iframe.parentElement;
                        const scale = container.offsetWidth / 1280;
                        iframe.style.transform = `scale(${scale})`;
                        const blob = new Blob([item.html], { type: 'text/html' });
                        iframe.src = URL.createObjectURL(blob);
                    }
                });
            }, 100);
        }

        function previewHistoryItem(index) {
            const item = historyMetadata[index];
            if (item) {
                updatePreviewFrameNew(item.html);
                showToast(`Previewing version from ${item.timestamp.toLocaleTimeString()}`, '');
            }
        }

        function restoreHistoryItem(index) {
            const item = historyMetadata[index];
            if (item) {
                currentHTML = item.html;
                updatePreviewFrameNew(currentHTML);
                addToHistory('Restored from earlier version', currentHTML);
                showToast('Version restored!', 'success');
                renderHistoryTimeline();
            }
        }

        // ========== CLICK OUTSIDE HANDLERS ==========
        document.addEventListener('click', (e) => {
            const toolbar = document.getElementById('floatingToolbar');
            const inlineEdit = document.getElementById('inlineEditContainer');

            if (!toolbar.contains(e.target) && !e.target.closest('.canvas-wrapper')) {
                hideAllToolbars();
            }

            if (!inlineEdit.contains(e.target) && !e.target.closest('.canvas-wrapper')) {
                cancelInlineEdit();
            }
        });

        // ========== NEW LOVABLE-STYLE FUNCTIONS ==========

        let selectedTemplateNew = 'modern-minimal';

        function switchWelcomeTabNew(tab) {
            // Update tab buttons
            document.querySelectorAll('.welcome-tab-new').forEach(btn => {
                btn.style.background = 'transparent';
                btn.style.color = '#666';
                btn.classList.remove('active');
            });
            event.target.style.background = '#fff';
            event.target.style.color = '#1a1a1a';
            event.target.classList.add('active');

            // Show/hide tab content
            document.getElementById('generateTabNew').style.display = tab === 'generate' ? 'block' : 'none';
            document.getElementById('uploadTabNew').style.display = tab === 'upload' ? 'block' : 'none';
            document.getElementById('pasteTabNew').style.display = tab === 'paste' ? 'block' : 'none';
        }

        function selectTemplateNew(card) {
            // Remove selection from all cards
            document.querySelectorAll('.template-card-new').forEach(c => {
                c.style.border = '2px solid #e5e7eb';
                c.style.background = '#fff';
                c.classList.remove('selected');
            });

            // Select this card
            card.style.border = '2px solid #667eea';
            card.style.background = '#f8f9ff';
            card.classList.add('selected');
            selectedTemplateNew = card.dataset.template;
        }

        function loadPastedHtmlNew() {
            const html = document.getElementById('pasteHtmlNew').value.trim();
            if (!html) {
                addChatMessageNew('assistant', 'âš ï¸ Please paste some HTML code first');
                return;
            }

            currentHTML = html;
            htmlHistory = [currentHTML];
            document.getElementById('welcomeScreenNew').style.display = 'none';
            updatePreviewFrameNew(currentHTML);
            try { if (typeof extractDesignContext === 'function') extractDesignContext(currentHTML); } catch(e) { console.warn('Design context skipped:', e); }
            addChatMessageNew('assistant', 'âœ… HTML loaded! Click on any element to select it, then tell me what to change.');
        }

        function handleChatKeydownNew(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessageNew();
            }
        }

        function addChatMessageNew(role, content) {
            const container = document.getElementById('chatMessagesNew');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;
            messageDiv.innerHTML = `<div class="chat-message-content">${content}</div>`;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            return messageDiv;
        }

        async function sendChatMessageNew() {
            const input = document.getElementById('chatInputNew');
            const message = input.value.trim();
            if (!message) return;

            addChatMessageNew('user', message);
            input.value = '';

            // Show loading
            const loadingMsg = addChatMessageNew('assistant', 'â³ Working on it...');

            try {
                if (currentHTML && currentHTML.length > 100) {
                    // Build selected element context with maximum info
                    let selectedElementData = null;
                    if (selectedComponent) {
                        selectedElementData = {
                            selector: selectedComponent.selector,
                            tag: selectedComponent.tag,
                            classes: selectedComponent.classes,
                            text: selectedComponent.text,
                            outer_html: selectedComponent.outer_html,
                            color_classes: selectedComponent.color_classes
                        };
                        console.log('Sending edit with selected element:', selectedElementData);
                    }

                    // Edit existing website
                    const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            html: currentHTML,
                            edit_instruction: message,
                            design_context: designContext,
                            selected_element: selectedElementData,
                            use_browserbase: true  // Enable Browserbase for visual verification
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Edit API error:', response.status, errorText);
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('Edit response:', data.success, 'HTML length:', data.html?.length);

                    if (data.success && data.html) {
                        // Verify HTML actually changed
                        if (data.html !== currentHTML) {
                            const beforeHTML = currentHTML;
                            htmlHistory.push(currentHTML);
                            currentHTML = data.html;
                            updatePreviewFrameNew(currentHTML);
                            // Design context extraction is optional - don't block on it
                            try { if (typeof extractDesignContext === 'function') extractDesignContext(currentHTML); } catch(e) { console.warn('Design context extraction skipped:', e); }

                            // Show before/after comparison
                            showBeforeAfterComparison(beforeHTML, currentHTML, data.summary || 'Edit applied', loadingMsg);
                        } else {
                            console.warn('Edit returned same HTML - no change detected');
                            loadingMsg.querySelector('.chat-message-content').textContent = 'âš ï¸ No changes detected. Try being more specific about what to change.';
                        }
                    } else {
                        console.error('Edit failed:', data.error);
                        loadingMsg.querySelector('.chat-message-content').textContent = `âŒ ${data.error || 'Edit failed - try again'}`;
                    }
                } else {
                    loadingMsg.querySelector('.chat-message-content').textContent = 'ðŸ’¡ Generate a website first, then I can help you edit it!';
                }
            } catch (error) {
                console.error('Edit error:', error);
                loadingMsg.querySelector('.chat-message-content').textContent = `âŒ Error: ${error.message}`;
            }
        }

        async function generateWebsiteNew() {
            const username = document.getElementById('usernameNew').value.trim();
            if (!username) {
                addChatMessageNew('assistant', 'âš ï¸ Please enter a Topmate username');
                return;
            }

            // Hide welcome screen
            document.getElementById('welcomeScreenNew').style.display = 'none';

            addChatMessageNew('user', `Generate website for @${username}`);
            const loadingMsg = addChatMessageNew('assistant', 'ðŸš€ Building your website...');

            try {
                const response = await fetch(`${AI_BASE}/api/build/website`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: username,
                        template_id: selectedTemplateNew
                    })
                });

                const data = await response.json();
                if (data.html) {
                    currentHTML = data.html;
                    currentUsername = username;
                    htmlHistory = [currentHTML];
                    document.getElementById('previewUrl').textContent = `${username}.topmate.io`;
                    updatePreviewFrameNew(currentHTML);
                    try { if (typeof extractDesignContext === 'function') extractDesignContext(currentHTML); } catch(e) { console.warn('Design context skipped:', e); }
                    loadingMsg.querySelector('.chat-message-content').textContent = 'âœ… Website created! Click on any element to select it, then tell me what to change.';
                } else {
                    loadingMsg.querySelector('.chat-message-content').textContent = `âŒ ${data.error || 'Failed to generate'}`;
                    document.getElementById('welcomeScreenNew').style.display = 'flex';
                }
            } catch (error) {
                loadingMsg.querySelector('.chat-message-content').textContent = `âŒ Error: ${error.message}`;
                document.getElementById('welcomeScreenNew').style.display = 'flex';
            }
        }

        function handleFileUploadNew(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                currentHTML = e.target.result;
                htmlHistory = [currentHTML];
                document.getElementById('welcomeScreenNew').style.display = 'none';
                updatePreviewFrameNew(currentHTML);
                try { if (typeof extractDesignContext === 'function') extractDesignContext(currentHTML); } catch(e) { console.warn('Design context skipped:', e); }
                addChatMessageNew('assistant', 'âœ… HTML uploaded! Click on any element to select it, then tell me what to change.');
            };
            reader.readAsText(file);
        }

        function updatePreviewFrameNew(html) {
            const container = document.getElementById('newCanvasWrapper');
            if (!html) return;

            // Remove welcome screen if still visible
            const welcome = document.getElementById('welcomeScreenNew');
            if (welcome) welcome.style.display = 'none';

            // Remove old iframe
            const oldFrame = container.querySelector('iframe');
            if (oldFrame) oldFrame.remove();

            // Create new iframe
            const newFrame = document.createElement('iframe');
            newFrame.id = 'previewFrameNew';
            newFrame.className = 'preview-frame';
            newFrame.style.cssText = 'width: 100%; height: 100%; border: none;';
            container.appendChild(newFrame);

            // Add edit mode styles and click handler
            const editModeStyles = `
                <style>
                    .ai-edit-hover { outline: 2px dashed #667eea !important; cursor: pointer !important; }
                    .ai-edit-selected { outline: 2px solid #667eea !important; background: rgba(102, 126, 234, 0.05) !important; }
                    .ai-inline-edit-popup {
                        position: fixed;
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 8px;
                        padding: 12px;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.4);
                        z-index: 99999;
                        min-width: 300px;
                        max-width: 500px;
                    }
                    .ai-inline-edit-popup textarea {
                        width: 100%;
                        min-height: 60px;
                        background: #2a2a2a;
                        border: 1px solid #444;
                        border-radius: 6px;
                        color: #fff;
                        padding: 8px;
                        font-size: 14px;
                        resize: vertical;
                    }
                    .ai-inline-edit-popup .btn-row {
                        display: flex;
                        gap: 8px;
                        margin-top: 8px;
                        justify-content: flex-end;
                    }
                    .ai-inline-edit-popup button {
                        padding: 6px 16px;
                        border-radius: 6px;
                        border: none;
                        cursor: pointer;
                        font-size: 13px;
                    }
                    .ai-inline-edit-popup .btn-save {
                        background: #667eea;
                        color: white;
                    }
                    .ai-inline-edit-popup .btn-cancel {
                        background: #444;
                        color: #ccc;
                    }
                    ::selection {
                        background: rgba(102, 126, 234, 0.4);
                    }
                </style>
            `;

            const modifiedHtml = html.replace('</head>', editModeStyles + '</head>');
            newFrame.srcdoc = modifiedHtml;

            newFrame.onload = function() {
                const doc = newFrame.contentDocument;
                if (!doc) return;

                doc.body.addEventListener('mouseover', (e) => {
                    if (e.target !== doc.body && e.target !== doc.documentElement) {
                        e.target.classList.add('ai-edit-hover');
                    }
                });

                doc.body.addEventListener('mouseout', (e) => {
                    e.target.classList.remove('ai-edit-hover');
                });

                // Single click - select element
                doc.body.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // Remove old selection
                    doc.querySelectorAll('.ai-edit-selected').forEach(el => el.classList.remove('ai-edit-selected'));

                    // Select new element
                    e.target.classList.add('ai-edit-selected');
                    selectedElement = e.target;

                    // Store component info
                    selectedComponent = {
                        element: e.target,
                        selector: getSelector(e.target),
                        tag: e.target.tagName.toLowerCase(),
                        classes: Array.from(e.target.classList).filter(c => !c.startsWith('ai-')),
                        text: e.target.textContent?.substring(0, 200),
                        outer_html: e.target.outerHTML?.substring(0, 2000),
                        color_classes: getColorClasses(e.target)
                    };

                    // Show selection in chat
                    if (e.target.tagName.toLowerCase() === 'img') {
                        showSelectedImageInChat(e.target);
                    } else {
                        const selectedText = e.target.textContent?.substring(0, 50) || e.target.tagName;
                        const tagName = e.target.tagName.toLowerCase();
                        addChatMessageNew('assistant', `ðŸ“ Selected <strong>${tagName}</strong>: "${selectedText}${selectedText.length >= 50 ? '...' : ''}"<br><span style="color: #888; font-size: 12px;">Tell me what changes you'd like to make.</span>`);
                    }

                    // Update suggestion chips based on selected element
                    updateSuggestionChips();
                });

                // Double click - inline text editing (for entire element)
                doc.body.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // Only for text elements
                    const tag = e.target.tagName.toLowerCase();
                    if (['img', 'video', 'iframe', 'svg', 'canvas'].includes(tag)) return;

                    // Show inline edit popup
                    showInlineEditPopup(e.target, doc, newFrame);
                });

                // Text selection - mouseup to detect selected text
                doc.body.addEventListener('mouseup', (e) => {
                    // Small delay to ensure selection is complete
                    setTimeout(() => {
                        const selection = doc.getSelection();
                        const selectedText = selection?.toString().trim();

                        // Only show popup if text is selected (more than just a click)
                        if (selectedText && selectedText.length > 0) {
                            const range = selection.getRangeAt(0);
                            const parentElement = range.commonAncestorContainer.nodeType === 3
                                ? range.commonAncestorContainer.parentElement
                                : range.commonAncestorContainer;

                            // Don't show for non-text elements
                            const tag = parentElement.tagName?.toLowerCase();
                            if (['img', 'video', 'iframe', 'svg', 'canvas', 'html', 'body'].includes(tag)) return;

                            showTextSelectionPopup(selectedText, parentElement, range, doc, newFrame);
                        }
                    }, 10);
                });
            };
        }

        // Show inline text edit popup
        function showInlineEditPopup(element, doc, frame) {
            // Remove any existing popup
            const existing = doc.querySelector('.ai-inline-edit-popup');
            if (existing) existing.remove();

            // Get element position
            const rect = element.getBoundingClientRect();
            const frameRect = frame.getBoundingClientRect();

            // Create popup in parent document (not iframe)
            const popup = document.createElement('div');
            popup.className = 'ai-inline-edit-popup';
            popup.style.cssText = `
                position: fixed;
                top: ${frameRect.top + rect.top + rect.height + 10}px;
                left: ${frameRect.left + rect.left}px;
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 8px;
                padding: 12px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.4);
                z-index: 99999;
                min-width: 300px;
                max-width: 500px;
            `;

            const currentText = element.textContent || '';
            popup.innerHTML = `
                <div style="font-size: 12px; color: #888; margin-bottom: 8px;">Edit text directly:</div>
                <textarea style="width: 100%; min-height: 60px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: #fff; padding: 8px; font-size: 14px; resize: vertical;">${currentText}</textarea>
                <div style="display: flex; gap: 8px; margin-top: 8px; justify-content: flex-end;">
                    <button class="btn-cancel" style="padding: 6px 16px; border-radius: 6px; border: none; cursor: pointer; font-size: 13px; background: #444; color: #ccc;">Cancel</button>
                    <button class="btn-save" style="padding: 6px 16px; border-radius: 6px; border: none; cursor: pointer; font-size: 13px; background: #667eea; color: white;">Save</button>
                </div>
            `;

            document.body.appendChild(popup);

            const textarea = popup.querySelector('textarea');
            textarea.focus();
            textarea.select();

            // Handle save
            popup.querySelector('.btn-save').onclick = async () => {
                const newText = textarea.value;
                if (newText !== currentText) {
                    await applyInlineTextEdit(element, currentText, newText);
                }
                popup.remove();
            };

            // Handle cancel
            popup.querySelector('.btn-cancel').onclick = () => {
                popup.remove();
            };

            // Handle Enter to save (Shift+Enter for new line)
            textarea.onkeydown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    popup.querySelector('.btn-save').click();
                }
                if (e.key === 'Escape') {
                    popup.remove();
                }
            };

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                });
            }, 100);
        }

        // Show text selection replacement popup
        function showTextSelectionPopup(selectedText, parentElement, range, doc, frame) {
            // Remove any existing popup
            const existingPopup = document.querySelector('.ai-text-selection-popup');
            if (existingPopup) existingPopup.remove();

            // Get selection position
            const rect = range.getBoundingClientRect();
            const frameRect = frame.getBoundingClientRect();

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'ai-text-selection-popup';
            popup.style.cssText = `
                position: fixed;
                top: ${frameRect.top + rect.bottom + 8}px;
                left: ${Math.max(10, frameRect.left + rect.left)}px;
                background: #1a1a1a;
                border: 1px solid #667eea;
                border-radius: 10px;
                padding: 14px;
                box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
                z-index: 99999;
                min-width: 320px;
                max-width: 450px;
            `;

            popup.innerHTML = `
                <div style="font-size: 11px; color: #667eea; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Edit Selected Text</div>
                <div style="font-size: 12px; color: #888; margin-bottom: 10px; padding: 8px; background: #2a2a2a; border-radius: 6px; border-left: 3px solid #667eea;">
                    "${selectedText.length > 60 ? selectedText.substring(0, 60) + '...' : selectedText}"
                </div>
                <input type="text" class="replace-input" placeholder="New text (leave empty to keep same)" style="width: 100%; padding: 10px 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: #fff; font-size: 14px; outline: none; box-sizing: border-box; margin-bottom: 10px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 12px; color: #999;">Color:</label>
                    <input type="color" class="color-input" value="#667eea" style="width: 36px; height: 28px; border: none; border-radius: 4px; cursor: pointer; padding: 0; background: transparent;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; color: #888;">
                        <input type="checkbox" class="apply-color-checkbox" style="cursor: pointer;"> Apply color
                    </label>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button class="btn-cancel" style="flex: 1; padding: 8px 12px; border-radius: 6px; border: 1px solid #444; cursor: pointer; font-size: 13px; background: #2a2a2a; color: #ccc; transition: all 0.2s;">Cancel</button>
                    <button class="btn-apply" style="flex: 1; padding: 8px 12px; border-radius: 6px; border: none; cursor: pointer; font-size: 13px; background: #667eea; color: white; transition: all 0.2s;">Apply</button>
                </div>
            `;

            document.body.appendChild(popup);

            const input = popup.querySelector('.replace-input');
            const colorInput = popup.querySelector('.color-input');
            const applyColorCheckbox = popup.querySelector('.apply-color-checkbox');
            input.focus();

            // Handle apply
            const doApply = async () => {
                const newText = input.value.trim();
                const applyColor = applyColorCheckbox.checked;
                const colorValue = colorInput.value;

                // Need at least one change (text or color)
                if (!newText && !applyColor) {
                    input.style.border = '1px solid #ef4444';
                    input.placeholder = 'Enter text or select color';
                    return;
                }

                popup.remove();
                await applySelectedTextReplace(selectedText, newText || selectedText, parentElement, applyColor ? colorValue : null);
            };

            popup.querySelector('.btn-apply').onclick = doApply;

            // Handle cancel
            popup.querySelector('.btn-cancel').onclick = () => {
                popup.remove();
                doc.getSelection()?.removeAllRanges();
            };

            // Handle Enter to apply, Escape to cancel
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    doApply();
                }
                if (e.key === 'Escape') {
                    popup.remove();
                    doc.getSelection()?.removeAllRanges();
                }
            };

            // Hover effects
            const btnCancel = popup.querySelector('.btn-cancel');
            const btnApply = popup.querySelector('.btn-apply');
            btnCancel.onmouseenter = () => { btnCancel.style.background = '#3a3a3a'; };
            btnCancel.onmouseleave = () => { btnCancel.style.background = '#2a2a2a'; };
            btnApply.onmouseenter = () => { btnApply.style.background = '#5567d5'; };
            btnApply.onmouseleave = () => { btnApply.style.background = '#667eea'; };

            // Close on click outside (with delay to prevent immediate close)
            setTimeout(() => {
                document.addEventListener('click', function closeSelectionPopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        doc.getSelection()?.removeAllRanges();
                        document.removeEventListener('click', closeSelectionPopup);
                    }
                });
            }, 200);
        }

        // Apply selected text replacement with layout restructuring and optional color
        async function applySelectedTextReplace(oldText, newText, parentElement, colorValue = null) {
            const beforeHTML = currentHTML;

            // Build user message
            let userMsg = '';
            if (oldText !== newText) {
                userMsg = `Replace: "${oldText.substring(0, 30)}${oldText.length > 30 ? '...' : ''}" â†’ "${newText.substring(0, 30)}${newText.length > 30 ? '...' : ''}"`;
            }
            if (colorValue) {
                userMsg += (userMsg ? ' | ' : '') + `Color: ${colorValue}`;
            }
            addChatMessageNew('user', userMsg);

            const loadingMsg = addChatMessageNew('assistant', 'â³ Applying changes...');

            // Build instruction
            let instruction = '';
            const targetText = newText !== oldText ? newText : oldText;

            if (oldText !== newText) {
                instruction = `Replace ONLY the exact text "${oldText}" with "${newText}". `;
            }
            if (colorValue) {
                instruction += `IMPORTANT: Change the color of ONLY the specific text "${targetText}" to ${colorValue} by wrapping it in a <span style="color: ${colorValue};">. Do NOT change the color of the entire paragraph or container - ONLY wrap the specific selected text "${targetText}" in a span with the color style. `;
            }
            instruction += `If the new text is longer or shorter than the original, adjust the layout, spacing, padding, font-size, or container as needed to ensure proper fit. The final result should look professionally designed.`;

            try {
                const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        edit_instruction: instruction,
                        selected_element: parentElement ? {
                            selector: getSelector(parentElement),
                            tag: parentElement.tagName?.toLowerCase(),
                            text: parentElement.textContent?.substring(0, 500),
                            outer_html: parentElement.outerHTML?.substring(0, 2000)
                        } : null
                    })
                });

                const data = await response.json();
                if (data.success && data.html && data.html !== currentHTML) {
                    htmlHistory.push(currentHTML);
                    currentHTML = data.html;
                    updatePreviewFrameNew(currentHTML);

                    // Build summary
                    let summary = '';
                    if (oldText !== newText) {
                        summary = `Changed text to "${newText.substring(0, 20)}..."`;
                    }
                    if (colorValue) {
                        summary += (summary ? ' and ' : '') + `applied color ${colorValue}`;
                    }
                    showBeforeAfterComparison(beforeHTML, currentHTML, summary, loadingMsg);
                } else {
                    loadingMsg.querySelector('.chat-message-content').innerHTML = 'âš ï¸ Could not apply changes. Try using the chat instead.';
                }
            } catch (error) {
                loadingMsg.querySelector('.chat-message-content').innerHTML = `âŒ Error: ${error.message}`;
            }
        }

        // Apply inline text edit
        async function applyInlineTextEdit(element, oldText, newText) {
            // Store before state
            const beforeHTML = currentHTML;

            // Show loading in chat
            addChatMessageNew('user', `Change text: "${oldText.substring(0, 30)}..." â†’ "${newText.substring(0, 30)}..."`);
            const loadingMsg = addChatMessageNew('assistant', 'â³ Updating text...');

            try {
                const response = await fetch(`${AI_BASE}/api/edit/optimized`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        html: currentHTML,
                        edit_instruction: `Change the text content from "${oldText}" to "${newText}"`,
                        selected_element: {
                            selector: getSelector(element),
                            tag: element.tagName.toLowerCase(),
                            text: oldText,
                            outer_html: element.outerHTML?.substring(0, 2000)
                        }
                    })
                });

                const data = await response.json();
                if (data.success && data.html && data.html !== currentHTML) {
                    htmlHistory.push(currentHTML);
                    currentHTML = data.html;
                    updatePreviewFrameNew(currentHTML);

                    // Show before/after comparison
                    showBeforeAfterComparison(beforeHTML, currentHTML, `Changed text to "${newText.substring(0, 30)}..."`, loadingMsg);
                } else {
                    loadingMsg.querySelector('.chat-message-content').innerHTML = 'âš ï¸ Could not update text. Try using the chat instead.';
                }
            } catch (error) {
                loadingMsg.querySelector('.chat-message-content').innerHTML = `âŒ Error: ${error.message}`;
            }
        }

        // Show selected image in chat
        function showSelectedImageInChat(imgElement) {
            const imgSrc = imgElement.src || imgElement.getAttribute('src');
            const imgAlt = imgElement.alt || 'Selected image';

            const messageHtml = `
                <div style="margin-bottom: 8px;">ðŸ“ Selected image:</div>
                <div style="display: inline-block; border-radius: 8px; overflow: hidden; margin-bottom: 8px;">
                    <img src="${imgSrc}" alt="${imgAlt}" style="max-width: 200px; max-height: 150px; border-radius: 6px; display: block; object-fit: contain;">
                </div>
                <div style="font-size: 13px; color: #888;">Tell me to replace it with a new image URL, or describe changes.</div>
            `;

            return addChatMessageNewHtml('assistant', messageHtml);
        }

        // Add chat message with HTML content
        function addChatMessageNewHtml(role, htmlContent) {
            const container = document.getElementById('chatMessagesNew');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}`;
            messageDiv.innerHTML = `
                <div class="chat-message-avatar">${role === 'user' ? 'ðŸ‘¤' : 'ðŸ¤–'}</div>
                <div class="chat-message-content">${htmlContent}</div>
            `;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            return messageDiv;
        }

        // Show before/after comparison in chat
        function showBeforeAfterComparison(beforeHTML, afterHTML, summary, existingMsg) {
            // Add to history timeline with the NEW html (afterHTML)
            addToHistory(summary, afterHTML);

            const timestamp = Date.now();
            const beforeId = 'before-iframe-' + timestamp;
            const afterId = 'after-iframe-' + timestamp;

            // Track which version is currently being previewed
            let previewingBefore = false;

            const comparisonHtml = `
                <div style="margin-bottom: 12px; font-size: 13px;">âœ… ${summary}</div>
                <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                    <div class="preview-card before-card" style="flex: 1; min-width: 0; cursor: pointer; padding: 8px; border-radius: 8px; border: 2px solid #333; background: #1e1e1e; transition: all 0.2s;">
                        <div style="font-size: 11px; color: #999; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Before</div>
                        <div class="preview-container" style="border-radius: 4px; overflow: hidden; width: 100%; aspect-ratio: 16/10; position: relative;">
                            <iframe id="${beforeId}" style="position: absolute; top: 0; left: 0; width: 1280px; height: 800px; transform-origin: top left; pointer-events: none; border: none; background: #fff;"></iframe>
                        </div>
                        <div style="font-size: 10px; color: #666; margin-top: 6px; text-align: center;">Click to preview</div>
                    </div>
                    <div class="preview-card after-card selected-card" style="flex: 1; min-width: 0; cursor: pointer; padding: 8px; border-radius: 8px; border: 2px solid #667eea; background: #1e1e1e; transition: all 0.2s;">
                        <div style="font-size: 11px; color: #667eea; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">After (current)</div>
                        <div class="preview-container" style="border-radius: 4px; overflow: hidden; width: 100%; aspect-ratio: 16/10; position: relative;">
                            <iframe id="${afterId}" style="position: absolute; top: 0; left: 0; width: 1280px; height: 800px; transform-origin: top left; pointer-events: none; border: none; background: #fff;"></iframe>
                        </div>
                        <div style="font-size: 10px; color: #666; margin-top: 6px; text-align: center;">Click to preview</div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="revert-btn" style="flex: 1; padding: 10px 12px; background: #2a2a2a; color: #ccc; border: 1px solid #444; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s;">â†© Undo change</button>
                    <button class="keep-btn" style="flex: 1; padding: 10px 12px; background: #667eea; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s;">âœ“ Keep change</button>
                </div>
            `;

            if (existingMsg) {
                existingMsg.querySelector('.chat-message-content').innerHTML = comparisonHtml;

                // Load HTML into iframes using blob URLs for better rendering
                setTimeout(() => {
                    const beforeIframe = document.getElementById(beforeId);
                    const afterIframe = document.getElementById(afterId);

                    // Calculate scale based on container width
                    const setIframeScale = (iframe) => {
                        if (!iframe) return;
                        const container = iframe.parentElement;
                        if (container) {
                            const containerWidth = container.offsetWidth;
                            const scale = containerWidth / 1280;
                            iframe.style.transform = `scale(${scale})`;
                        }
                    };

                    if (beforeIframe) {
                        const beforeBlob = new Blob([beforeHTML], { type: 'text/html' });
                        beforeIframe.src = URL.createObjectURL(beforeBlob);
                        beforeIframe.onload = () => setIframeScale(beforeIframe);
                        setIframeScale(beforeIframe);
                    }
                    if (afterIframe) {
                        const afterBlob = new Blob([afterHTML], { type: 'text/html' });
                        afterIframe.src = URL.createObjectURL(afterBlob);
                        afterIframe.onload = () => setIframeScale(afterIframe);
                        setIframeScale(afterIframe);
                    }
                }, 50);

                // Get card elements
                const beforeCard = existingMsg.querySelector('.before-card');
                const afterCard = existingMsg.querySelector('.after-card');
                const revertBtn = existingMsg.querySelector('.revert-btn');
                const keepBtn = existingMsg.querySelector('.keep-btn');

                // Function to update card selection UI
                const updateCardSelection = (selectBefore) => {
                    if (selectBefore) {
                        beforeCard.style.border = '2px solid #f59e0b';
                        afterCard.style.border = '2px solid #333';
                        beforeCard.querySelector('div:first-child').innerHTML = '<span style="color: #f59e0b;">BEFORE (previewing)</span>';
                        afterCard.querySelector('div:first-child').innerHTML = '<span style="color: #999;">AFTER</span>';
                    } else {
                        beforeCard.style.border = '2px solid #333';
                        afterCard.style.border = '2px solid #667eea';
                        beforeCard.querySelector('div:first-child').innerHTML = '<span style="color: #999;">BEFORE</span>';
                        afterCard.querySelector('div:first-child').innerHTML = '<span style="color: #667eea;">AFTER (current)</span>';
                    }
                };

                // Click handlers for cards - preview in main iframe
                if (beforeCard) {
                    beforeCard.onclick = () => {
                        previewingBefore = true;
                        updatePreviewFrameNew(beforeHTML);
                        updateCardSelection(true);
                    };
                }

                if (afterCard) {
                    afterCard.onclick = () => {
                        previewingBefore = false;
                        updatePreviewFrameNew(afterHTML);
                        updateCardSelection(false);
                    };
                }

                // Button hover effects
                if (revertBtn) {
                    revertBtn.onmouseenter = () => { revertBtn.style.background = '#3a3a3a'; revertBtn.style.borderColor = '#666'; };
                    revertBtn.onmouseleave = () => { revertBtn.style.background = '#2a2a2a'; revertBtn.style.borderColor = '#444'; };
                    revertBtn.onclick = () => {
                        // Confirm revert to before version
                        currentHTML = beforeHTML;
                        htmlHistory.pop();
                        updatePreviewFrameNew(currentHTML);
                        existingMsg.querySelector('.chat-message-content').innerHTML = '<div style="color: #f59e0b;">â†© Reverted to previous version</div>';
                        showToast('Reverted to previous version', 'success');
                    };
                }

                if (keepBtn) {
                    keepBtn.onmouseenter = () => { keepBtn.style.background = '#5567d5'; };
                    keepBtn.onmouseleave = () => { keepBtn.style.background = '#667eea'; };
                    keepBtn.onclick = () => {
                        // Confirm keeping the after version
                        currentHTML = afterHTML;
                        updatePreviewFrameNew(currentHTML);
                        existingMsg.querySelector('.chat-message-content').innerHTML = `<div style="color: #10b981;">âœ“ ${summary}</div>`;
                        showToast('Changes kept', 'success');
                    };
                }
            }
        }

    </script>
</body>
</html>
